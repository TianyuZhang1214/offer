
#热门题解
##数学
###1. 反转序列(LintCode 532. Reverse Pairs)
描述: 
For an array A, if i < j, and A [i] > A [j], called (A [i], A [j]) is a reverse pair.
return total of reverse pairs in A. 
Example: 
Given A = [2, 4, 1, 3, 5] , (2, 1), (4, 1), (4, 3) are reverse pairs. return 3.
思路：变形的mergeSort。
Code: 

```
class Solution {
public:
    /**
     * @param A: an array
     * @return: total of reverse pairs
     */
    int mergeSort(int left, int right, vector<int> &A){
        if(left >= right) return 0;
        int mid = (left + right)/ 2;
        int res = mergeSort(left, mid, A) + mergeSort(mid+1, right, A);
        int i, j;
        for(i = left, j = mid+1; i <= mid; i++){
            while(j <= right && A[j] < A[i]) j++;
            res += j-(mid+1);
        }
        sort(A.begin()+left, A.begin()+right+1);
        return res;
    }
   
    long long reversePairs(vector<int> &A) {
        // write your code here
       return mergeSort(0, A.size()-1, A);
    }
};
``` 
###2. 斐波纳契数列(LintCode 366. Fibonacci)
描述: 
Find the Nth number in Fibonacci sequence. 
A Fibonacci sequence is defined as follow: 
The first two numbers are 0 and 1. 
The i th number is the sum of i-1 th number and i-2 th number. 
The first ten numbers in Fibonacci sequence is: 
`0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...` 
Example:
Given `1`, return `0` 
Given `2`, return `1` 
Given `10`, return `34`   
思路：递归太慢，不一定能过OJ。 
Code: 

```
class Solution {
public:
    /**
     * @param n: an integer
     * @return: an ineger f(n)
     */
    int fibonacci(int n) {
        // write your code here
        if(n <= 1) return 0;
        if(n == 2) return 1;
        int res = 0;
        int f1 = 0, f2 = 1;
        int i;
        for(i = 3;i <= n;++i){
            res = f1 + f2;
            f1 = f2;
            f2 = res;
        }
        return res;
    }
}; 
``` 
 
###3. x的平方根(LintCode 141. Sqrt(x))
描述: 
Implement int sqrt(int x). 
Compute and return the square root of x. 
Example: 
sqrt(3) = 1 
sqrt(4) = 2 
sqrt(5) = 2 
sqrt(10) = 3 
思路：
二分查找。 
Code: 

```
class Solution {
public:
    /**
     * @param x: An integer
     * @return: The sqrt of x
     */
    int sqrt(int x) {
        // write your code here
        int low = 0, high = 46341, mid = 0;
        while(low <= high){
            if(mid == low + (high - low)/ 2) break;
           
            mid = low + (high - low)/ 2;
            if(mid*mid == x) break;
            else if(mid*mid > x) high = mid;
            else low = mid;
           
        }
        return mid;
    }
};
```

###4. 骰子求和(LintCode 20. 骰子求和)
描述: 
Throw n dices, the sum of the dices' faces is S. Given n, find the all possible value of S along with its probability. 
Example: 
Given `n = 1`, return `[ [1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]`. 
思路: 
动态规划，注意相互之间的关系。 
Code: 

```
class Solution {
public:
    /**
     * @param n an integer
     * @return a list of pair<sum, probability>
     */
    vector<pair<int, double> > dicesSum(int n) {
        // Write your code here
        vector<pair<int, double> > res;
       
        double res_tmp[n+1][6*n+1];
        memset(res_tmp, 0, sizeof(res_tmp));
        int i, j, k;
        for(i = 1; i <= 6; ++i) res_tmp[1][i] = 1.0/6;
       
        for(i = 2; i <= n; ++i)
            for(j = i; j < 6*i +1; ++j){
                for(k = 1; k <= 6; ++k)
                    if(j > k) res_tmp[i][j] += res_tmp[i-1][j-k]/6.0;
            }       
        for(i = n; i< 6*n+1; ++i) res.push_back(make_pair(i, res_tmp[n][i]));
        return res;
       
    }
};
```
###4. 最多有多少个点在一条直线上(LintCode 186. Max Points on a Line )
描述: 
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.   
Example: 
Given 4 points: `(1,2)`, `(3,6)`, `(0,0)`, `(1,3)`. 
The maximum number is `3`. 
思路: 
C++ STL中map的使用。 
Code: 

```
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    /**
     * @param points: an array of point
     * @return: An integer
     */
    int maxPoints(vector<Point> &points) {
        // write your code here
        if(points.size() <= 2) return points.size();
        map<double, int> count;
        int max = INT_MIN;
        int i, j, same_point;
        double rate;
        for(i=0;i<points.size();++i){
            count.clear();
            same_point = 0;
            count[(double)INT_MIN] = 1;
            for(j = i+1;j<points.size();j++){
                if(points[i].x == points[j].x && points[i].y == points[j].y){
                    ++same_point;
                    continue;
                }
                if(points[i].x - points[j].x == 0 ) rate = (double)INT_MAX;
                else rate = (double)(points[j].y-points[i].y) / (double)(points[j].x-points[i].x);
               
                if(count.find(rate) != count.end()) count[rate] += 1;
                else count[rate] = 2;
            }
           
            for(auto c:count)
                max = c.second + same_point > max ? c.second + same_point : max;
        }
        return max;
    }
};
```

###5. 超级丑数(LintCode 518. Super Ugly Number )
描述: 
Write a program to find the nth super ugly number.
Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size `k`. For example, `[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]` is the sequence of the first 12 super ugly numbers given primes = `[2, 7, 13, 19]` of size `4`. 
Example: 
Given n = `6`, primes = `[2, 7, 13, 19]` return `13`. 
思路: 
建立缓存数组存储中间结果，与丑数类似。 
Code: 

```
/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
    /**
     * @param points: an array of point
     * @return: An integer
     */
    int maxPoints(vector<Point> &points) {
        // write your code here
        if(points.size() <= 2) return points.size();
        map<double, int> count;
        int max = INT_MIN;
        int i, j, same_point;
        double rate;
        for(i=0;i<points.size();++i){
            count.clear();
            same_point = 0;
            count[(double)INT_MIN] = 1;
            for(j = i+1;j<points.size();j++){
                if(points[i].x == points[j].x && points[i].y == points[j].y){
                    ++same_point;
                    continue;
                }
                if(points[i].x - points[j].x == 0 ) rate = (double)INT_MAX;
                else rate = (double)(points[j].y-points[i].y) / (double)(points[j].x-points[i].x);
               
                if(count.find(rate) != count.end()) count[rate] += 1;
                else count[rate] = 2;
            }
           
            for(auto c:count)
                max = c.second + same_point > max ? c.second + same_point : max;
        }
        return max;
    }
};
```
###6. 大数乘法
描述: 
Code: 

```
char* multi(char* a, char* b){
    int length_a = 0;
    int length_b = 0;
    while(*(a++) != '\0') ++length_a;
    while(*(b++) != '\0') ++length_b;
    a -= (length_a+1);
    b -= (length_b+1);

    int i, j, k, m, tag, tmp_1, res;
    char *c = (char*)malloc(sizeof(char)*(length_a+length_b+1));
    for(i = 0; i< length_a+length_b+1;++i) c[i] = '0';

    tag = 0;
    char *tmp = (char*)malloc(sizeof(char)*(length_b+1));

    for(i= length_a-1;i>=0;--i){
        for(m = 0; m < length_b+1;++m) tmp[m] = '0';
        for(j = length_b-1; j>=0; --j){
            res = (int)(a[i]-'0') * (int)(b[j]-'0') + tag;
            tmp_1 = res%10;
            tag = res/10;
            tmp[j+1] = tmp_1 + '0';
        }
        tmp[0] = tag + '0';
        tag = 0;
        for(k = length_b;k >= 0;--k){
            res = (int)(c[k+i+1] - '0') + (int)(tmp[k] - '0') + tag;
            tmp_1 = res%10;
            tag = res/10;
            c[k+i+1] = tmp_1 + '0';
        }
        c[i+1] = tag + '0';
        tag = 0;
    }
    while(*c == '0') ++c;
    return c；
}
``` 
##比特位操作
###1. 将整数A转换为B(LintCode 181. Flip Bits)
描述: 
Determine the number of bits required to flip if you want to convert integer n to integer m.
Example: 
Given `n = 31 (11111)`, `m = 14 (01110)`, return `2`. 
思路:
注意负数。
Code: 

```
class Solution {
public:
    /**
     * @param a: An integer
     * @param b: An integer
     * @return: An integer
     */
    int bitSwapRequired(int a, int b) {

        int c = a ^ b;
        int count = 0;
        for(int i = 0;i < 32;++i){
            count += (c&1);
            c >>= 1;
        }
        return count;
    }
};
```
###2. 更新二进制位(LintCode 179. Update Bits) 
描述: 
Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j) 
Example: 
Given `N=(10000000000)2, M=(10101)2, i=2, j=6` 
return `N=(10001010100)2`   
Code: 

```
class Solution {
public:
    /**
     * @param n: An integer
     * @param m: An integer
     * @param i: A bit position
     * @param j: A bit position
     * @return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        // write your code here
        int tmp = 1;
        int k;
        for(k = 0;k < 32 - j;++k){
            tmp <<= 1;
            ++tmp;
        }
       
        for(k = 0; k < j-i+1; ++k) tmp <<= 1;
       
        for(k = 0; k< i;++k){
            tmp <<= 1;
            ++tmp;
        }
       
       
        n &= tmp;
        for(k = 0; k < i;++k) m <<= 1;
        n |= m;
        return n;
    }
}; 
```
###3. O(1)时间检测2的幂次(LintCode 142. O(1) Check Power of 2 ) 
描述： 
Using O(1) time to check whether an integer n is a power of 2.
Example: 
For n=4, return true; 
For n=5, return false; 
Code: 

```
class Solution {
public:
    /**
     * @param n: An integer
     * @return: True or false
     */
    bool checkPowerOf2(int n) {
        if(n < 1) return false;
        else return (n & (n-1)) == 0;
    }
}; 
```
###4. 二进制中有多少个1(LintCode 365. Count 1 in Binary) 
描述： 
Count how many 1 in binary representation of a 32-bit integer. 
Example: 
Given 32, return 1 
Given 5, return 2 
Given 1023, return 9 
Code: 

```
class Solution {
public:
    /*
     * @param num: An integer
     * @return: An integer
     */
    int countOnes(int num) {
        // write your code here
        int count = 0;
        for(int i = 0; i < 32; ++i) count += (num >> i)&1;
        return count;
    }
};
```

###5. 二进制表示 (LintCode 180. Binary Representation) 
描述： 
Given a (decimal - e.g. 3.72) number that is passed in as a string, return the binary representation that is passed in as a string. If the fractional part of the number can not be represented accurately in binary with at most 32 characters, return ERROR. 
Example: 
For n = "3.72", return "ERROR". 
For n = "3.5", return "11.1". 
Code: 

```
class Solution {
public:
    /**
     * @param n: Given a decimal number that is passed in as a string
     * @return: A string
     */
    string binaryRepresentation(string &n) {
       // write your code here
    stack<int> inte_tmp;
    long long inte = 0;
    double frac = 0.0;
    int i, j;
    int flag = 1;
    string inte_s = "", frac_s = "";

    for(i = 0; i < n.length(); ++i){
        if(n[i] == '.') break;
        inte = inte * 10 + (n[i]-'0');
    }
    if(inte == 0) inte_s += '0';

    for(j = i+1 ; j < n.length(); ++j){
        frac = frac + (double)(n[j] - '0')/pow(10,j-i);
    }
    if(frac <= 1e-15) flag = 0;
   
    for(i = 0;i< 32; ++i){
        frac *= 2;
        if(int(frac) > 0) {
            frac_s += "1";
            frac -= 1.0;
        }
        else frac_s += "0";
    }
   
    if(frac > 1e-15) return "ERROR";
   
    while(inte > 0){
        cout<< inte <<endl;
        inte_tmp.push(inte&1);
        inte >>= 1;
    }
    while(!inte_tmp.empty()){
        inte_s += (inte_tmp.top() + '0');
        inte_tmp.pop();
    }
    while(frac_s[frac_s.length()-1] == '0') frac_s.pop_back();
    if(flag == 1) return inte_s+'.'+frac_s;
    else return inte_s;
}
};
```
##堆化
###1. 滑动窗口的中位数(LintCode 360. 滑动窗口的中位数 )
描述: 
Given an array of n integer, and a moving window(size k), move the window at each iteration from the start of the array, find the median of the element inside the window at each moving. (If there are even numbers in the array, return the N/2-th number after sorting the element in the window. ) 
Example: 
For array `[1,2,7,8,5]`, moving window size `k = 3`. return `[2,7,7]` 
At first the window is at the start of the array like this 
`[ | 1,2,7 | ,8,5]` , return the median `2`; 
then the window move one step forward. 
`[1, | 2,7,8 | ,5]`, return the median `7`; 
then the window move one step forward again. 
`[1,2, | 7,8,5 | ]`, return the median `7`; 
思路:  
建一个最大堆，一个最小堆用于保存数据，注意STL中multiset的使用。 
Code: 

``` 
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @param k: An integer
     * @return: The median of the element inside the window at each moving
     */
   
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
   
        vector<double> res;
        if(nums.empty() || k == 0) return res;
        if(k == 1){
            for(int i = 0; i< nums.size();++i) res.push_back((double)nums[i]);
            return res;
        }
        multiset<int> small, large;
        int lsize, ssize;
        lsize = k/2;
        if(k&1) ssize = lsize + 1;
        else ssize = lsize;

        for (int i = 0; i < nums.size(); ++i){
            if(i >= k){
                if(small.count(nums[i-k])) small.erase(small.find(nums[i-k]));
                else if(large.count(nums[i-k])) large.erase(large.find(nums[i-k]));
            }
            small.insert(nums[i]);

            if(small.size() > ssize){
                large.insert(*small.begin());
                small.erase(small.begin());
            }

            if(i+1 >= k){
                if(ssize == lsize) res.push_back((*small.begin()+*(--large.end()))/2.0);
                else res.push_back(*small.begin());
            }else continue;
        }
        return res;
    }
};
```
###2. 数据流中位数(LintCode 81. Data Stream Median) 
描述: 
Numbers keep coming, return the median of numbers at every time a new number added. 
Example: 
For numbers coming list: `[1, 2, 3, 4, 5]`, return `[1, 1, 2, 2, 3]`. 
For numbers coming list: `[4, 5, 1, 3, 2, 6, 0]`, return `[4, 4, 4, 3, 3, 3, 3]`. 
For numbers coming list: `[2, 20, 100]`, return `[2, 2, 20]`. 
思路:   
建一个最大堆，一个最小堆用于保存数据，注意STL中multiset的使用。 
Code: 
``` 
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @return: the median of numbers
     */
    vector<int> medianII(vector<int> &nums) {
        // write your code here
        vector<int> res;
        priority_queue<int, vector<int>, less<int>> big_heap;       
        priority_queue<int, vector<int>, greater<int>> small_heap;
       
        for(int i = 0; i< nums.size(); ++i){
            if(i%2==0){
                big_heap.push(nums[i]);
                small_heap.push(big_heap.top());
                big_heap.pop();
            }
            else{
                small_heap.push(nums[i]);
                big_heap.push(small_heap.top());
                small_heap.pop();
            }
           
            if(i&1) res.push_back(big_heap.top());
            else res.push_back(small_heap.top());
        }
        return res;
    }
};
```
###3. 最高频的K个单词(LintCode 471. Top K Frequent Words) 
描述: 
Given a list of words and an integer k, return the top k frequent words in the list.
Example: 
Given 

```
[
    "yes", "lint", "code", 
    "yes", "code", "baby", 
    "you", "baby", "chrome",
    "safari", "lint", "code",
    "body", "lint", "code"
]
```
for `k = 3`, return `["code", "lint", "baby"]`.
for `k = 4`, return `["code", "lint", "baby", "yes"]`, 
思路:   
好好利用stl中的map和vector pair。
Code: 

```
class Solution {
public:
    /**
     * @param words: an array of string
     * @param k: An integer
     * @return: an array of string
     */
    static bool cmp(const pair<int, string> &p1, const pair<int, string> &p2){
        return p1.first > p2.first;
    }
   
    vector<string> topKFrequentWords(vector<string> &words, int k) {
        // write your code here
        vector<string> res;
        map<string, int> data;
       
        for(int i = 0; i< words.size();++i){
            if(data.find(words[i]) != data.end()) ++data[words[i]];
            else data[words[i]] = 1;
        }
        vector<pair<int,string> > arr; 
       
        for(map<string, int>::iterator it = data.begin(); it != data.end(); ++it)
            arr.push_back(make_pair(it->second, it->first));
           
        sort(arr.begin(), arr.end(), cmp);
       
       
        for(int i = 0; i < k; ++i) res.push_back(arr[i].second);
       
        return res;
    }
};
```
###4. 堆化(LintCode 130. Heapify ) 
描述: 
Given an integer array, heapify it into a min-heap array. 
For a heap array A, A[0] is the root of heap, and for each A[i], A[i * 2 + 1] is the left child of A[i] and A[i * 2 + 2] is the right child of A[i]. 
Example: 
Given [3,2,1,4,5], return [1,2,3,4,5] or any legal heap array. 
Code: 

```
class Solution {
public:
    /*
     * @param A: Given an integer array
     * @return: nothing
     */
    void adjust(vector<int> &A, int i){
        int left = 2*i + 1;
        int right = 2*i + 2;
        int small = i;
        int tmp;
        if(left < A.size() && A[left] < A[i]) small = left;
        if(right < A.size() && A[right] < A[small]) small = right;
        if(small != i){
            tmp = A[i];
            A[i] =  A[small];
            A[small] = tmp;
            adjust(A, small);
        }
    }
   
    void heapify(vector<int> &A) {
        // write your code here
        int tmp;
        for(int i = A.size()/2; i >= 0; --i){
            adjust(A, i);
        }
    }
   
   
};
```
###5. 排序矩阵中的从小到大第k个数(LintCode 401. 排序矩阵中的从小到大第k个数) 
描述: 
在一个排序矩阵中找从小到大的第 k 个整数。 
排序矩阵的定义为：每一行递增，每一列也递增。 
Example: 
给出 k = 4 和一个排序矩阵： 

```
[ 
  [1 ,5 ,7], 
  [3 ,7 ,8], 
  [4 ,8 ,9], 
] 
```
返回 `5`。 
思路： 
注意排序矩阵每次的自我调整。 
Code: 

```
class Solution {
public:
    /**
     * @param matrix: a matrix of integers
     * @param k: An integer
     * @return: the kth smallest number in the matrix
     */
    int kthSmallest(vector<vector<int>> &matrix, int k) {
        // write your code here
        int sizerow = matrix.size();
        int sizecol = matrix[0].size();
        if(sizerow <= 0 || sizecol <= 0) return 0;
        int min;
        for(int i = 0; i < k; ++i) {
            min = matrix[0][0];
            matrix[0][0] = INT_MAX;
            adjust(matrix);
        }
        return min;
    }
   
    void adjust(vector<vector<int>> &matrix){
        int col = 0, row = 0;
        while(row < matrix.size() - 1 && col < matrix[0].size() - 1){
            if(matrix[row][col + 1] <= matrix[row+1][col]){
                swap(matrix[row][col+1], matrix[row][col]);
                ++col;
            }
            else{
                swap(matrix[row+1][col], matrix[row][col]);
                ++row;
            }
        }
       
        while(row == matrix.size() - 1 && col < matrix[0].size() - 1){
            if(matrix[row][col+1] < matrix[row][col])
                swap(matrix[row][col+1], matrix[row][col]);
            ++col;
        }

        while(col == matrix[0].size() - 1 && row < matrix.size() - 1){
            if(matrix[row+1][col] < matrix[row][col])
                swap(matrix[row+1][col], matrix[row][col]);
            ++row;
        }
    }
};
```
###6. 接雨水 II(LintCode 364. 接雨水 II) 
描述: 
Given n x m non-negative integers representing an elevation map 2d where the area of each cell is 1 x 1, compute how much water it is able to trap after raining. 
Example:  
例如，给定一个 5*4 的矩阵：

```
[
  [12,13,0,12],
  [13,4,13,12],
  [13,8,10,12],
  [12,13,12,12],
  [13,13,13,13]
] 
```
返回 `14`. 
思路：  
先求出海拔高度，然后用海拔高度逐个减去内侧的元素值求出积水高度，再加起来可以得到总的蓄水值. 
Code: 

```
class Solution {
public:
    /**
     * @param heights: a matrix of integers
     * @return: an integer
     */
    int min(int a, int b, int c, int d){
        int min_value = a < b ? a : b;
        min_value = min_value < c ? min_value: c;
        min_value = min_value < d ? min_value: d;
        return min_value;
    }
   
    int trapRainWater(vector<vector<int> > &heights) {
    // write your code here
    int res = 0;
    if(heights.size() <= 2 || heights[0].size() <=2) return res;

    multiset<int> left;
    multiset<int> right;
    multiset<int> up;
    multiset<int> down;

    int i, j, k;
    int min_value;

    int rowsize = heights.size();
    int colsize = heights[0].size();

    for(i = 1; i < rowsize - 1;++i){
        up.insert(heights[i-1][1]);
        left.insert(heights[i][0]);
        for(k = 2;k < colsize; ++k) right.insert(heights[i][k]);
        for(k = 2;k < rowsize; ++k) down.insert(heights[k][1]);
        for(j = 1; j < colsize - 1; ++j){
            min_value = min(*up.rbegin(), *down.rbegin(), *left.rbegin(), *right.rbegin());
            left.insert(heights[i][j]);
            right.erase(right.find(heights[i][j+1]));
        }
        up.insert(heights[i][j]);
        down.erase(up.find(heights[i+1][j]));
    }

    for(i = 1; i < rowsize - 1;++i){
        for(j = 1; j < colsize - 1; ++j){
            if(min_value > heights[i][j]) res += min_value - heights[i][j];
        }
    }
    return res;
}
}; 
```
##二叉树
###1. 二叉树中序遍历(LintCode 67. Binary Tree Inorder Traversal )
描述: 
Given a binary tree, return the inorder traversal of its nodes' values. 
Example: 
Example
Given binary tree {1,#,2,3}, 

```
   1 
    \ 
     2 
    / 
   3 
```
return `[1,3,2]`. 
Code: 

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    vector<int> inorderTraversal(TreeNode * root) {
        // write your code here
        vector<int> res;
        if(!root) return res;
       
        mid(root, res);
        return res;
    }
    void mid(TreeNode *root, vector<int> &res){
       
        if(!root->left && !root->right) {
            res.push_back(root->val);
            return;
        }
       
        if(root->left) mid(root->left, res);
        res.push_back(root->val);
        if(root->right) mid(root->right, res);
    }
};
``` 
###2. 二叉树的序列化和反序列化(LintCode 7. Serialize and Deserialize Binary Tree)
描述: 
Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called 'serialization' and reading back from the file to reconstruct the exact same binary tree is 'deserialization'. 
Example: 
An example of testdata: Binary tree {3,9,20,#,#,15,7}, denote the following structure: 

```
  3 
 / \ 
9  20 
  /  \ 
 15   7   
```

Our data serialization use bfs traversal. This is just for when you got wrong answer and want to debug the input.
You can use other method to do serializaiton and deserialization. 
Code:  

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */


class Solution {
public:
    /**
     * This method will be invoked first, you should design your own algorithm
     * to serialize a binary tree which denote by a root node to a string which
     * can be easily deserialized by your own "deserialize" method later.
     */
    string serialize(TreeNode * root) {
       
        // write your code here
        if (root==NULL)
    {
        return "";//return NULL出错;
    }
    string result;   
    //result=result+to_string(root->val);
    result=result+int2str(root->val);

    queue<TreeNode *> level;
    level.push(root->left);
    level.push(root->right);
   
    while(!level.empty())
    {
        TreeNode *temp=level.front();
        level.pop();
        if (temp!=NULL)
        {
            //result=result+","+to_string(temp->val);
            result=result+","+int2str(temp->val);
            level.push(temp->left);
            level.push(temp->right);
        }
        else
        {
            result=result+","+"#";
        }   
    }

    int size=result.size();
    int id=size-1;
    while(id>0&&(result[id]=='#'||result[id]==','))
    {
        id--;
    }
    result.resize(id+1);

    return result;
    }

    /**
     * This method will be invoked second, the argument data is what exactly
     * you serialized at method "serialize", that means the data is not given by
     * system, it's given by your own serialize method. So the format of data is
     * designed by yourself, and deserialize it here as you serialize it in
     * "serialize" method.
     */
    TreeNode * deserialize(string &data) {
        // write your code here
        if (data.empty())
    {
        return NULL;
    }

    int size=data.size();
    int i=0;
    int ro=0;//根节点数值;
    while(data[i]!=','&&i<size)
    {
        char tm=data[i];
        ro=ro*10+tm-'0';
        i++;
    }
    TreeNode * root=new TreeNode(ro);
   
    queue<TreeNode *> level;
    TreeNode *index=root;   
    bool isLeft=true;

    for (;i<size;i++)
    {
        if (data[i]==',')
        {
            continue;
        }
        else if (data[i]=='#')
        {
            if (isLeft)
            {
                //index->left=NULL;
                isLeft=false;
            }
            else
            {
                //index->right=NULL;
                if (!level.empty())
                {
                    index=level.front();
                    level.pop();
                }
                isLeft=true;
            }   
        }
        else
        {
            int val=0;
            while(i<size&&data[i]!=',') //注意不能写成data[i]!=','&&i<size，因为下标可能超出范围;
            {
                char temp=data[i];
                val=val*10+temp-'0';
                i++;
            }
           
            TreeNode * tempNode=new TreeNode(val);
            level.push(tempNode);
            if (isLeft)
            {
                index->left=tempNode;
                isLeft=false;
            }
            else
            {
                index->right=tempNode;
                if (!level.empty())
                {
                    index=level.front();
                    level.pop();
                }
                isLeft=true;
            }   
        }       
    }
    return root;
    }
   
   
    string int2str(int &i)
{
    string str;
    stringstream stream;
    stream<<i;
    str=stream.str();//stream>>str;
    return str;
}

}; 
```
###3. 子树(LintCode 245. Subtree)
描述: 
You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1. 
Example: 
T2 is a subtree of T1 in the following case: 

```
       1                3 
      / \              /  
T1 = 2   3      T2 =  4 
        / 
       4 
```
T2 isn't a subtree of T1 in the following case: 

```
       1               3 
      / \               \ 
T1 = 2   3       T2 =    4 
        / 
       4 
```
Code:  

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param T1: The roots of binary tree T1.
     * @param T2: The roots of binary tree T2.
     * @return: True if T2 is a subtree of T1, or false.
     */
    bool isSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1 == NULL && pRoot2 != NULL)
            return false;
        if(pRoot2 == NULL)
            return true;
        bool flag = false;
        if(pRoot1->val == pRoot2->val){
            flag = IsSubtree(pRoot1, pRoot2);
        }
        if(!flag){
            flag = isSubtree(pRoot1->left, pRoot2);
        }
        if(!flag){
            flag = isSubtree(pRoot1->right, pRoot2);
        }
        return flag;
    }
    bool IsSubtree(TreeNode* pRoot1, TreeNode* pRoot2){
        if(pRoot1 == NULL && pRoot2 != NULL)
            return false;
        if(pRoot2 == NULL)
            return true;
        if(pRoot1->val != pRoot2->val)
            return false;
        return IsSubtree(pRoot1->left, pRoot2->left) && IsSubtree(pRoot1->right, pRoot2->right);
    }
   
};
``` 
###4. 最近公共祖先(LintCode 88. Lowest Common Ancestor)
描述: 
Given the root and two nodes in a Binary Tree. Find the lowest common ancestor(LCA) of the two nodes.
The lowest common ancestor is the node with largest depth which is the ancestor of both nodes. 
Example: 
For the following binary tree: 

```
  4
 / \
3   7
   / \
  5   6
LCA(3, 5) = 4
LCA(5, 6) = 7
LCA(6, 7) = 7 
```
Code:  

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */


class Solution {
public:
    /*
     * @param root: The root of the binary search tree.
     * @param A: A TreeNode in a Binary.
     * @param B: A TreeNode in a Binary.
     * @return: Return the least common ancestor(LCA) of the two nodes.
     */

    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * A, TreeNode * B) {
        // write your code here
       if(!root || A == root || B == root) return root;
       TreeNode *left = lowestCommonAncestor(root->left, A, B);
       TreeNode *right = lowestCommonAncestor(root->right, A, B);
       if(left && right) return root;
       return left ? left:right;
    }
};
```
###5. 二叉树的层次遍历(LintCode 69. Binary Tree Level Order Traversal)
描述: 
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). 
Example: 
Given binary tree `{3,9,20,#,#,15,7}`, 

```
    3
   / \
  9  20
    /  \
   15   7
 
```
return its level order traversal as: 

```
[
  [3],
  [9,20],
  [15,7]
]
```
Code:  

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Level order a list of lists of integer
     */
    vector<vector<int>> levelOrder(TreeNode * root) {
        // write your code here
        queue<TreeNode *> odd, even;
        vector<vector<int> > res;
        TreeNode *node;
        int level = 1;
        even.push(root);
        if(!root) return res;
       
        while(!odd.empty() || !even.empty()){
            if(level&1){
                vector<int> tmp;
                while(!even.empty()){
                    node = even.front();
                    tmp.push_back(node->val);
                    even.pop();
                    if(node->left) odd.push(node->left);
                    if(node->right) odd.push(node->right);
                }
                res.push_back(tmp);
                ++level;
            }else{
                vector<int> tmp;
                while(!odd.empty()){
                    node = odd.front();
                    tmp.push_back(node->val);
                    odd.pop();
                    if(node->left) even.push(node->left);
                    if(node->right) even.push(node->right);
                }
                res.push_back(tmp);
                ++level;
            }
        }
       
       
    }
};
``` 
###6. 将二叉树拆成链表(LintCode 453. Flatten Binary Tree to Linked List)
描述: 
Flatten a binary tree to a fake "linked list" in pre-order traversal. 
Here we use the right pointer in TreeNode as the next pointer in ListNode. 
Example: 

```
              1 
               \ 
     1          2 
    / \          \ 
   2   5    =>    3 
  / \   \          \ 
 3   4   6          4 
                     \ 
                      5
                       \
                        6
```
思路：不停拆分左子树，将其并到右子树来实现。 
Code:  

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    void flatten(TreeNode * root) {
        // write your code here
        while(root){
            if(root->left){
                TreeNode *cur = root->left;
                while(cur->right) cur = cur->right;
                cur->right = root->right;
                root->right = root->left;
                root->left = NULL;
            }
            root = root->right;
        }
       
    }
   
};
```
###7. 在二叉查找树中插入节点(LintCode 85. Insert Node in a Binary Search Tree)
描述: 
Given a binary search tree and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.  
Example: 
Given binary search tree as follow, after Insert node 6, the tree should be: 

```
  2             2
 / \           / \
1   4   -->   1   4
   /             / \
  3             3   6 
```
Code:  

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */


class Solution {
public:
    /*
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    TreeNode * insertNode(TreeNode * root, TreeNode * node) {
        // write your code here
        if(!root){
            root = node;
        }
        else if(node->val > root->val) root->right = insertNode(root->right, node);
        else if(node->val < root->val) root->left = insertNode(root->left, node);
       
        return root;
    }
};
```
##二叉树
###1. 经典二分查找问题(LintCode 457. Classical Binary Search)
描述: 
Find any position of a target number in a sorted array. Return -1 if target does not exist.
Example: 
Given `[1, 2, 2, 4, 5, 5]`. 
For target = `2`, return 1 or 2. 
For target = `5`, return 4 or 5. 
For target = `6`, return -1. 
Code: 

```
class Solution {
public:
    /*
     * @param nums: An integer array sorted in ascending order
     * @param target: An integer
     * @return: An integer
     */
   
    int findPosition(vector<int> &nums, int target) {
        // write your code here
        int start = 0, end = nums.size() - 1;
        while(start < end){
            int mid = start + (end - start)/2;
            if(nums[mid] == target) return mid;
            else if(target < nums[mid]) end = mid - 1;
            else if(target > nums[mid]) start = mid + 1;
        }
        return -1;
    }
};
``` 
###2. 两数组的交(LintCode 457. Classical Binary Search)
描述: 
返回两个数组的交
Example: 
nums1 = `[1, 2, 2, 1]`, nums2 = `[2, 2]`, 返回 `[2]`. 
Code: 

```
class Solution {
public:
   
    /*
     * @param nums1: an integer array
     * @param nums2: an integer array
     * @return: an integer array
     */
    bool binarysearch(vector<int> nums,int target){
        int start = 0, end = nums.size();
        if(nums.size() == 1) return nums[0] == target ? true:false;
       
        while(start < end){
            int mid = start + (end - start)/ 2;
            if(nums[mid] == target) return true;
            else if(nums[mid] > target) end = mid - 1;
            else if(nums[mid] < target) start = mid + 1;
        }
       
        return false;
       
    }
    vector<int> intersection(vector<int> nums1, vector<int> nums2) {
        // write your code here
        vector<int> res;
        if(nums1.empty() || nums2.empty()) return res;
       
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
       
        int i;
       
        if(binarysearch(nums2, nums1[0])) res.push_back(nums1[0]);
        for(i = 1;i < nums1.size() ;++i){
            if(nums1[i] != nums1[i-1] && binarysearch(nums2, nums1[i])) res.push_back(nums1[i]);
            else continue;
        }
        return res;
    }
};
```
###3. 寻找旋转排序数组中的最小值(LintCode 159. 寻找旋转排序数组中的最小值)
描述: 
假设一个旋转排序的数组其起始位置是未知的（比如`0 1 2 4 5 6 7` 可能变成是`4 5 6 7 0 1 2`）。 
你需要找到其中最小的元素。 
你可以假设数组中不存在重复的元素。 
Example:   
给出`[4,5,6,7,0,1,2]`,返回 0. 
Code: 

```
class Solution {
public:
    /**
     * @param nums: a rotated sorted array
     * @return: the minimum number in the array
     */

    int findMin(vector<int> &nums) {
        // write your code here
        int low = 0, high = nums.size() - 1;
        int mid;
        if(nums[low] <= nums[high]) return nums[low];
        while(low < high){
            mid = low + (high - low)/ 2;
            if(nums[mid] >= nums[high]) low = mid + 1;
            else high = mid;
        }
        return nums[low] < nums[high] ? nums[low]:nums[high];
    }
};
```
###4. 搜索排序区间(LintCode 61. Search for a Range)
描述: 
Given a sorted array of n integers, find the starting and ending position of a given target value.
If the target is not found in the array, return [-1, -1]. 
Example:   
Given `[5, 7, 7, 8, 8, 10]` and target value `8`, 
return `[3, 4]`. 
思路: 注意二分法分别查找第一个数的位置和最后一个数的位置的区别。 
Code: 

```
class Solution {
public:
    /**
     * @param A: an integer sorted array
     * @param target: an integer to be inserted
     * @return: a list of length 2, [index1, index2]
     */
    int findstart(vector<int> &A, int target){
        int low = 0, high = A.size() - 1;
        int mid;
        while(low+1 < high){
            mid = low + (high - low)/2;
            if(A[mid] == target) high = mid;
            else if(target > A[mid]) low = mid;
            else if(target < A[mid]) high = mid;
        }
        if(A[low] == target) return low;
        if(A[high] == target) return high;
        return -1;
    }
    int findend(vector<int> &A, int target){
        int low = 0, high = A.size() - 1;
        int mid;
        while(low+1 < high){
            mid = low + (high - low)/2;
            if(A[mid] == target) low = mid;
            else if(target > A[mid]) low = mid;
            else if(target < A[mid]) high = mid;
        }
        if(A[high] == target) return high;
        if(A[low] == target) return low;
        return -1;
    }
    vector<int> searchRange(vector<int> &A, int target) {
        // write your code here
       
        vector<int> res;
        int pos1 = -1, pos2 = -1;
        if(A.size() == 0){
            res.push_back(pos1);
            res.push_back(pos2);
            return res;
        }
       
        pos1 = findstart(A, target);
        pos2 = findend(A, target);
       
        res.push_back(pos1);
        res.push_back(pos2);
       
        return res;
    }
};
```
###5. 寻找峰值 (LintCode 75. 寻找峰值)
描述: 
There is an integer array which has the following features: 
The numbers in adjacent positions are different. 
A[0] < A[1] && A[A.length - 2] > A[A.length - 1]. 
We define a position P is a peak if: 
`A[P] > A[P-1] && A[P] > A[P+1]`   
Find a peak element in this array. Return the index of the peak. 
Example:   
Given `[1, 2, 1, 3, 4, 5, 7, 6]` 
Return index `1` (which is number 2) or `6` (which is number 7) 
思路: 找到上升沿和下降沿，利用二分法计算，lintcode貌似有问题，最长的数组一直超时。 
Code: 

```
class Solution {
public:
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    int findPeak(vector<int> A) {
        // write your code here
        int left = 0; 
        int size = A.size();
        int right = size - 1; 
        while(left < right) { 
            int mid = left + (right - left)/2; 
            if(mid == 0) {
                return 1;
            } else if(mid == size - 1) {
                return mid - 1; 
            } else if(A[mid] > A[mid - 1] && A[mid] > A[mid + 1]) {
                return mid; 
            } else if(A[mid] < A[mid - 1]) {
                right = mid - 1; 
            } else { 
                left = mid + 1; 
            }
        } 
        return left; 
    }
};

/*Another version*/

class Solution {
public:
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    int findPeak(vector<int> A) {
    // write your code here
    int left = 1;
    int size = A.size();
    int right = size - 2;
    while(left+1 < right) {
        int mid = left + (right - left)/2;
        if(A[mid] > A[mid - 1] && A[mid] > A[mid + 1]) return mid;
        else if(A[left] > A[left-1] && A[left] > A[left+1]) return left;
        else if(A[right] > A[right-1] && A[right] > A[right+1]) return right;
        else if(A[mid] < A[mid - 1]) right = mid;
        else left = mid;
    }
    return left;
}
};
```
##线段树
###1. 线段树的构造(LintCode 201. Segment Tree Build)
描述: 
The structure of Segment Tree is a binary tree which each node has two attributes start and end denote an segment / interval. 
start and end are both integers, they should be assigned in following rules: 

* The root's start and end is given by build method. 
* The left child of node A has start=A.left, end=(A.left + A.right) / 2. 
* The right child of node A has start=(A.left + A.right) / 2 + 1, end=A.right. 
* if start equals to end, there will be no children for this node. 

Implement a `build` method with two parameters start and end, so that we can create a corresponding segment tree with every node has the correct start and end value, return the root of this segment tree.

Example: 

```
Given start=0, end=3. The segment tree will be:

               [0,  3]
             /        \
      [0,  1]           [2, 3]
      /     \           /     \
   [0, 0]  [1, 1]     [2, 2]  [3, 3]
Given start=1, end=6. The segment tree will be:
               [1,  6]
             /        \
      [1,  3]           [4,  6]
      /     \           /     \
   [1, 2]  [3,3]     [4, 5]   [6,6]
   /    \           /     \
[1,1]   [2,2]     [4,4]   [5,5] 
```
Code: 

```
/**
 * Definition of SegmentTreeNode:
 * class SegmentTreeNode {
 * public:
 *     int start, end;
 *     SegmentTreeNode *left, *right;
 *     SegmentTreeNode(int start, int end) {
 *         this->start = start, this->end = end;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /*
     * @param start: start value.
     * @param end: end value.
     * @return: The root of Segment Tree.
     */
    SegmentTreeNode * build(int start, int end) {
        // write your code here
        SegmentTreeNode *node = new SegmentTreeNode(start, end);
        if(start > end) return NULL;
        if(start != end){
            node->left = build(node->start, (node->start + node->end)/2);
            node->right = build((node->start+node->end)/ 2 + 1, node->end);
        }else{
            node->left = NULL;
            node->right = NULL;
        }
        return node;
    }
   
};
```
###2. 线段树的查询(LintCode 202. 线段树的查询)
描述: 
对于一个有n个数的整数数组，在对应的线段树中, 根节点所代表的区间为0-n-1, 每个节点有一个额外的属性max，值为该节点所代表的数组区间start到end内的最大值。
为SegmentTree设计一个 query 的方法，接受3个参数root, start和end，线段树root所代表的数组中子区间[start, end]内的最大值。 
Example: 
对于数组 [1, 4, 2, 3], 对应的线段树为：

```
                  [0, 3, max=4]
                 /             \
          [0,1,max=4]        [2,3,max=3]
          /         \        /         \
   [0,0,max=1] [1,1,max=4] [2,2,max=2], [3,3,max=3] 
```
query(root, 1, 1), return 4 
query(root, 1, 2), return 4 
query(root, 2, 3), return 3 
query(root, 0, 2), return 4  
Code: 

```
/**
 * Definition of SegmentTreeNode:
 * class SegmentTreeNode {
 * public:
 *     int start, end, max;
 *     SegmentTreeNode *left, *right;
 *     SegmentTreeNode(int start, int end, int max) {
 *         this->start = start;
 *         this->end = end;
 *         this->max = max;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of segment tree.
     * @param start: start value.
     * @param end: end value.
     * @return: The maximum number in the interval [start, end]
     */
    int query(SegmentTreeNode * root, int start, int end) {
        // write your code here
        if(!root) return INT_MAX;
        if(start <= root->start && end >= root->end) return root->max;
        int mid = (root->start + root->end) / 2;
        if(start > mid) return query(root->right, start, end);
        else if(end < mid+1) return query(root->left, start, end);
        else return max(query(root->left, start, mid), query(root->right, mid+1, end));
    }
};
```
###3. 线段树的修改(LintCode 203. 线段树的修改)
描述: 
对于一棵 最大线段树, 每个节点包含一个额外的`max`属性，用于存储该节点所代表区间的最大值。 
设计一个 modify 的方法，接受三个参数`root`、 `index` 和 `value`。该方法将 root 为根的线段树中`[start, end] = [index, index]`的节点修改为了新的`value`，并确保在修改后，线段树的每个节点的 max 属性仍然具有正确的值。 
Example: 
对于线段树: 

```
                      [1, 4, max=3]
                    /                \
        [1, 2, max=2]                [3, 4, max=3]
       /              \             /             \
[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=3]  
```
如果调用 `modify(root, 2, 4)`, 返回: 

```
                      [1, 4, max=4]
                    /                \
        [1, 2, max=4]                [3, 4, max=3]
       /              \             /             \
[1, 1, max=2], [2, 2, max=4], [3, 3, max=0], [4, 4, max=3]  
```
或 调用 `modify(root, 4, 0)`, 返回: 

```
                      [1, 4, max=2]
                    /                \
        [1, 2, max=2]                [3, 4, max=0]
       /              \             /             \
[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=0] 
```
Code: 
 
```
/**
 * Definition of SegmentTreeNode:
 * class SegmentTreeNode {
 * public:
 *     int start, end, max;
 *     SegmentTreeNode *left, *right;
 *     SegmentTreeNode(int start, int end, int max) {
 *         this->start = start;
 *         this->end = end;
 *         this->max = max;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of segment tree.
     * @param index: index.
     * @param value: value
     * @return: nothing
     */
    void modify(SegmentTreeNode * root, int index, int value) {
        // write your code here
        if(index == root->start && index == root->end) {
            root->max = value;
            return;
        }
       
        int mid = (root->start+root->end)/2;
        if(index < mid+1) modify(root->left, index, value);
        else modify(root->right, index, value);
       
        root->max = max(root->left->max, root->right->max);
       
       
    }
};
```
###4. 区间求和 I(LintCode 206. 区间求和 I)
描述: 
给定一个整数数组（下标由 0 到 n-1，其中 n 表示数组的规模），以及一个查询列表。每一个查询列表有两个整数 [start, end] 。 对于每个查询，计算出数组中从下标 start 到 end 之间的数的总和，并返回在结果列表中。  
Example: 
对于数组 `[1,2,7,8,5]`，查询`[(1,2),(0,4),(2,4)]`, 返回 `[9,23,20]` 
Code:
 
```
/**
 * Definition of Interval:
 * classs Interval {
 *     int start, end;
 *     Interval(int start, int end) {
 *         this->start = start;
 *         this->end = end;
 *     }
 * }
 */
 
class SegmentTreeNode1{
public:
    int start,end;
    long long sum;
    SegmentTreeNode1* right,*left;
    SegmentTreeNode1(int start,int end){
        this->start=start;
        this->end=end;
        this->sum=0;
        this->left=this->right=NULL;
    }
   
};

class Solution {
public:
    /**
     * @param A: An integer list
     * @param queries: An query list
     * @return: The result list
     */
    SegmentTreeNode1* Build(vector<int> &A, int start, int end){
        SegmentTreeNode1* node = new SegmentTreeNode1(start,end);
        if(start > end) return NULL;
        if(start != end){
            node->left = Build(A, start, (start + end)/2);
            node->right = Build(A, (start + end)/2 + 1, end);
        }else{
            node->sum = A[start];
            return node;
        }
        node->sum = node->left->sum + node->right->sum;
        return node;
    }
   
    long long search(SegmentTreeNode1 *tree, int start, int end){
        if(start <= tree->start && end >= tree->end) return tree->sum;
        int mid = (tree->start + tree->end) / 2;
        if(start > mid) return search(tree->right, start, end);
        else if(end < mid + 1) return search(tree->left, start, end);
        else return (search(tree->left, start, mid) + search(tree->right, mid + 1, end));
    }
   
    vector<long long> intervalSum(vector<int> &A, vector<Interval> &queries) {
        // write your code here
        vector<long long> res;
       
        SegmentTreeNode1 *tree = Build(A, 0, A.size() - 1);
       
        for(int i = 0; i < queries.size(); ++i){
            res.push_back(search(tree, queries[i].start, queries[i].end));
        }
       
        return res;
    }
};
```
###5. 统计比给定整数小的数的个数(LintCode 248. 统计比给定整数小的数的个数)
描述: 
给定一个整数数组 （下标由 0 到 n-1，其中 n 表示数组的规模，数值范围由 0 到 10000），以及一个 查询列表。对于每一个查询，将会给你一个整数，请你返回该数组中小于给定整数的元素的数量。    
Example: 
对于数组 `[1,2,7,8,5]` ，查询 `[1,8,5]`，返回 `[0,4,2]` 
挑战: 
可否用一下三种方法完成以上题目。 
仅用循环方法 
分类搜索 和 二进制搜索 
构建 线段树 和 搜索 
Code:

```
/*线段树， 然后超时了*/
class TreeNode1{
    public:
        int start;
        int end;
        int count;
        TreeNode1 *left, *right;
        TreeNode1(int start, int end){
            this->start = start;
            this->end = end;
            this->count = count;
            this->left = this->right = NULL;
        }
};

class Solution {
public:
    /**
     * @param A: An integer array
     * @param queries: The query list
     * @return: The number of element in the array that are smaller that the given integer
     */
    TreeNode1* Build(vector<int> A, int start, int end,int target){
        TreeNode1 *node = new TreeNode1(start, end);
        if(start != end){
            node->left = Build(A, start, (start + end)/2, target);
            node->right = Build(A, (start + end)/2 + 1, end, target);
        }else{
            if(target > A[start]) node->count = 1;
            else node->count = 0;
            return node;
        }
        node->count = node->left->count + node->right->count;
        return node;
    }
    vector<int> countOfSmallerNumber(vector<int> &A, vector<int> &queries) {
        // write your code here
        vector<int> res;
        if(queries.empty()) return res;
        TreeNode1* tree;
        for(int i = 0; i< queries.size();++i) {
            if(A.empty()) res.push_back(0);
            else{
                tree = Build(A, 0, A.size() - 1, queries[i]);
                res.push_back(tree->count);
            }
        }
        return res;
    }
};
```
##分治法
###1. 快速幂(LintCode 140. Fast Power)
描述: 
Calculate the `a^n % b` where a, b and n are all 32bit integers. 
Example: 
For 2^31 % 3 = 2 
For 100^1000 % 1000 = 0 
Code: 

```
class Solution {
public:
    /**
     * @param a: A 32bit integer
     * @param b: A 32bit integer
     * @param n: A 32bit integer
     * @return: An integer
     */
   
    int fastPower(int a, int b, int n) {
        // write your code here
        long ans = 1, tmp = a;
        while(n > 0){
            if(n&1) ans = (ans * tmp)%b;
            tmp = (tmp * tmp) % b;
            n >>= 1;
        }
        
        return (int)ans%b;
    }
};
```
###2. 两个排序数组的中位数(LintCode 65. 两个排序数组的中位数) 
描述: 
两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。 
Example: 
给出数组A = [1,2,3,4,5,6] B = [2,3,4,5]，中位数3.5 
给出数组A = [1,2,3] B = [4,5]，中位数 3  
Code: 

``` 
class Solution {
public:
    /*
     * @param A: An integer array
     * @param B: An integer array
     * @return: a double whose format is *.5 or *.0
     */
    double binarysearch(vector<int> &A, vector<int> &B, int start_a, int start_b, int k){
       
        if(A.size() -start_a < B.size() - start_b) return binarysearch(B, A, start_b, start_a, k);
       
        if(B.size() == start_b) return A[start_a + k - 1];
       
        if(k == 1) return min(A[start_a], B[start_b]);
       
        int tmp_b = min(start_b + k/2, int(B.size()));
       
        int tmp_a = start_a + k - tmp_b + start_b;
       
        if(A[tmp_a - 1] < B[tmp_b - 1]) return binarysearch(A, B, tmp_a, start_b, k - tmp_a + start_a);
        else if(A[tmp_a - 1] > B[tmp_b - 1]) return binarysearch(A, B, start_a, tmp_b, k - tmp_b + start_b);
        else return A[tmp_a - 1];
       
    }
   
   
    double findMedianSortedArrays(vector<int> &A, vector<int> &B) {
        // write your code here
//        if(A.empty() && B.empty()) return NULL;
        int length = A.size() + B.size();

        if(length&1) return binarysearch(A, B, 0, 0, length/2+1);
        //else return 1;
        else return (binarysearch(A, B, 0, 0, length/2) + binarysearch(A, B, 0, 0, length/2+1))/2;
       
    }
};
```
###3. 合并K个排序链表(LintCode 104. Merge K Sorted Lists) 
描述: 
合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。 
Example: 
给出3个排序链表`[2->4->null,null,-1->null]`，返回 `-1->2->4->null` 
Code: 

```
/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this->val = val;
 *         this->next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    ListNode* merge2lists(ListNode *A, ListNode *B){
        ListNode *head = new ListNode(-1);
        ListNode *cur = head;
        while (A && B) {
            if (A->val < B->val) {
                cur->next = A;
                A = A->next;
            } else {
                cur->next = B;
                B = B->next;
            }
            cur = cur->next;
        }
        if (A) cur->next = A;
        if (B) cur->next = B;
        return head->next;
    }
   
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        if (lists.size() == 0) return NULL;
        int n = lists.size();
        int k;
       
        while (n > 1) {
            k = (n + 1) / 2;
           
            for (int i = 0; i < n / 2; ++i) {
                lists[i] = merge2lists(lists[i], lists[i + k]);
            }
           
            n = k;
        }
        return lists[0];
    }
};
```
##哈希表
###1. 哈希函数(LintCode 140. Fast Power)
描述: 
在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一个大整数，比如：

```
hashcode("abcd") = (ascii(a) * 333 + ascii(b) * 332 + ascii(c) *33 + ascii(d)) % HASH_SIZE

                              = (97* 333 + 98 * 332 + 99 * 33 +100) % HASH_SIZE

                              = 3595978 % HASH_SIZE

其中HASH_SIZE表示哈希表的大小(可以假设一个哈希表就是一个索引0 ~ HASH_SIZE-1的数组)。
```
给出一个字符串作为key和一个哈希表的大小，返回这个字符串的哈希值。 
Example: 
对于key="abcd" 并且 size=100， 返回 78 
思路: 注意取余操作的运算法则: (a+b)%c = a%c + b%c; (a\*b)%c = ((a%c)\*(b%c))%c 
Code: 

```
class Solution {
public:
    /**
     * @param key: A string you should hash
     * @param HASH_SIZE: An integer
     * @return: An integer
     */
    int hashCode(string &key, int HASH_SIZE) {
        // write your code here
        int size = key.length();
        if(size <= 0) {
            return 0;
        }
        long code = 0;
        long hashBase = 1;
        for(int i=size-1; i>=0; i--) {
            code = code + (key[i] * hashBase) % HASH_SIZE;
            code %= HASH_SIZE;
            hashBase = hashBase * 33 % HASH_SIZE;
        }
        return code;
    }
};
```
###2. 最小子串覆盖(LintCode 32. 最小子串覆盖) 
描述: 
给定一个字符串source和一个目标字符串target，在字符串source中找到包括所有目标字符串字母的子串。
Example: 
给出source = `"ADOBECODEBANC"`，target = `"ABC"` 满足要求的解  `"BANC"` 
思路:  
Code: 

```
class Solution {
public:
    /**
     * @param source : A string
     * @param target: A string
     * @return: A string denote the minimum window, return "" if there is no such a string
     */
    string minWindow(string &source , string &target) {
        // write your code here
        int i, countsource[128], counttarget[128];
        for(i = 0;i < 128; ++i){
            counttarget[i] = 0;
            countsource[i] = 0;
        }
       
        for(i = 0; i < target.length(); ++i) ++counttarget[target[i]];
        int start = 0, begin = -1, end = source.length(), tmp = 0, found = 0, minlen = source.length();
        for(i = 0; i < source.length(); ++i) {
            ++countsource[source[i]];
            if(countsource[source[i]] <= counttarget[source[i]]) ++found;
            if(found == target.length()){
                while(start < i && countsource[source[start]] > counttarget[source[start]]){
                    --countsource[source[start]];
                    ++start;
                }
               
                if(i - start < minlen){
                    begin = start;
                    end = i;
                    minlen = i - start;
                }
               
                countsource[source[start++]]--;
                --found;
            }
        }
        if(begin == -1) return string("");
        else return source.substr(begin, end - begin +1);
    }
};
```
###3. 复制带随机指针的链表(LintCode 105. 复制带随机指针的链表) 
描述: 
给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。 
返回一个深拷贝的链表。 
思路: 建立哈希表。
Code: 

```
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    /**
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
     */
    RandomListNode *copyRandomList(RandomListNode *head) {
        // write your code here
       
        map<RandomListNode*, RandomListNode*> hash;
       
        RandomListNode *cur = head;
       
        while(cur != nullptr){
            RandomListNode *tmp = new RandomListNode(cur->label);
            hash[cur] = tmp;
            cur = cur->next;
        }
       
        cur = head;
        RandomListNode* phead = hash[cur];
        RandomListNode* pcur = phead;
       
        while(cur != nullptr){
            pcur->next = hash[cur->next];
            pcur->random = hash[cur->random];
           
            pcur = pcur->next;
            cur = cur->next;
        }
       
        return phead;
    }
};
```
##矩阵
###1. 搜索二维矩阵(LintCode 28. Search a 2D Matrix)
描述: 
Write an efficient algorithm that searches for a value in an m x n matrix.
This matrix has the following properties:
Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row. 
Example: 
Consider the following matrix: 

```
[
    [1, 3, 5, 7],
    [10, 11, 16, 20],
    [23, 30, 34, 50]
]
```
Given `target = 3`, return `true`. 
Code: 

```
class Solution {
public:
    /**
     * @param matrix: matrix, a list of lists of integers
     * @param target: An integer
     * @return: a boolean, indicate whether matrix contains target
     */
    bool searchMatrix(vector<vector<int>> &matrix, int target) {
        // write your code here
        if(matrix.empty()) return false;
        int rowsize = matrix.size(), colsize = matrix[0].size();
       
        if(rowsize == 0 || colsize == 0) return false;

        int low = 0, high = matrix.size() - 1;
        int mid;
       
        while(low <= high && high >= 0){
            mid = low + (high - low)/2;
            if(matrix[mid][0] == target) return true;
            if(matrix[mid][0] < target) low = mid+1;
            else if(matrix[mid][0] > target) high = mid-1;
        }
        int c;       
        if(high < 0) c = low;
        else c = min(low, high);
        low = 0, high = matrix[0].size();
        while(low <= high){
            mid = low + (high - low)/2;
            if(matrix[c][mid] == target) return true;
            if(matrix[c][mid] < target) low = mid+1;
            else if(matrix[c][mid] > target) high = mid-1;           
        }
        return false;
    }
};
```
###2. 旋转图像(LintCode 161. Rotate Image)
描述: 
You are given an n x n 2D matrix representing an image. 
Rotate the image by 90 degrees (clockwise). 
Example: 
Given a matrix 

```
[
    [1,2],
    [3,4]
]
```
rotate it by 90 degrees (clockwise), return 

```
[
    [3,1],
    [4,2]
]
```
Code: 

```
class Solution {
public:
    /**
     * @param matrix: a lists of integers
     * @return: nothing
     */
   
    void rotate(vector<vector<int>> &matrix) {
        // write your code here
        if(matrix.empty()) return;
       
        int i, j;
        for(i = 0; i < matrix.size() - 1; ++i)
            for(j = i+1;j < matrix.size(); ++j)
                swap(matrix[i][j], matrix[j][i]);
       
        for(j = 0; j < matrix.size()/2; ++j)
            for(i = 0; i < matrix.size(); ++i)
                swap(matrix[i][j], matrix[i][matrix.size() - 1 - j]);
               
       
    }
};
```
###3. 岛屿的个数(LintCode 433. 岛屿的个数)
描述: 
给一个01矩阵，求不同的岛屿的个数。
0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。 
Example: 
在矩阵：

```
[
  [1, 1, 0, 0, 0],
  [0, 1, 0, 0, 1],
  [0, 0, 0, 1, 1],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1]
]
```

中有 3 个岛. 
Code: 

```
class Solution {
public:
    /**
     * @param grid: a boolean 2D matrix
     * @return: an integer
     */
    void setzero(vector<vector<bool>> &grid, int i, int j){
        grid[i][j] = 0;
        if(i-1 >=0)
            if(grid[i-1][j] == 1) setzero(grid, i-1, j);
        if(i+1 < grid.size())
            if(grid[i+1][j] == 1) setzero(grid, i+1, j);
        if(j-1 >= 0)
            if(grid[i][j-1] == 1) setzero(grid, i, j-1);
        if(j+1 < grid[0].size())
            if(grid[i][j+1] == 1) setzero(grid, i, j+1);
    }
   
   
    int numIslands(vector<vector<bool>> &grid) {
        // write your code here
        int i, j, count = 0;
        if(grid.empty()) return count;
        for(i = 0; i < grid.size(); ++i)
            for(j = 0; j < grid[0].size(); ++j){
                if(grid[i][j] == true){
                    count +=1;
                    if(i-1 >=0)
                        if(grid[i-1][j] == 1) setzero(grid, i-1, j);
                    if(i+1 < grid.size())
                        if(grid[i+1][j] == 1) setzero(grid, i+1, j);
                    if(j-1 >= 0)
                        if(grid[i][j-1] == 1) setzero(grid, i, j-1);
                    if(j+1 < grid[0].size())
                        if(grid[i][j+1] == 1) setzero(grid, i, j+1);
                }
                else continue;
            }
        return count;
    }
};
```
###4. Spiral Matrix(LintCode 374. Spiral Matrix)
描述: 
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 
Example: 
Given the following matrix: 

```
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
```
You should return `[1,2,3,6,9,8,7,4,5]`. 
Code: 

```
class Solution {
public:
    /**
     * @param matrix: a matrix of m x n elements
     * @return: an integer list
     */
    vector<int> spiralOrder(vector<vector<int>> &matrix) {
        // write your code here
        vector<int> result;
        if(matrix.empty()) return result;
       
        int i = 0, j = 0, row2 = matrix.size(), col2 = matrix[0].size(), row1= 0, col1 = 0;

        int count = 0;
        int ite = 0;
        while(true){
            for (int i = col1; i < col2; i++)
            {
                result.push_back(matrix[row1][i]);
       
            }
            row1++;
            if (row1 >= row2)break;
           
            for (int i = row1; i < row2; i++)
            {
                result.push_back(matrix[i][col2-1]);
       
            }
            col2--;
            if (col1 >= col2)break;

            for (int i = col2-1; i >= col1; i--)
            {
                result.push_back(matrix[row2-1][i]);
           
            }
            row2--;
            if (row1 >= row2)break;

            for (int i = row2-1; i >= row1; i--)
            {
                result.push_back(matrix[i][col1]);
            }
            col1++;
            if (col1 >= col2) break;
           
          
        }
       
        return result;
    }
};
```
##宽度优先搜索
###1. 克隆图(LintCode 137. Clone Graph)
描述: 
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. 
How we serialize an undirected graph: 
Nodes are labeled uniquely. 
We use # as a separator for each node, and , as a separator for node label and each neighbor of the node. 
As an example, consider the serialized graph {0,1,2#1,2#2,2}. 
The graph has a total of three nodes, and therefore contains three parts as separated by #. 
First node is labeled as 0. Connect node 0 to both nodes 1 and 2. 
Second node is labeled as 1. Connect node 1 to node 2. 
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. 
Visually, the graph looks like the following: 

```
   1
  / \
 /   \
0 --- 2
     / \
     \_/ 
``` 
思路：注意图的宽度优先搜索，注意建立邻接表的方法。 
Code:

```
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */


class Solution {
public:
    /*
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
        // write your code here
        if(node == nullptr) return node;
       
        queue<UndirectedGraphNode*> copy;
        copy.push(node);
       
        UndirectedGraphNode *head = new UndirectedGraphNode(node->label);
        queue<UndirectedGraphNode*> acopy;
        acopy.push(head);

        map<int, UndirectedGraphNode*> helper;
        helper[head->label] = head;

        UndirectedGraphNode *cur, *pcur;
       
        int i;
        while(!copy.empty()){
           
            cur = copy.front();
            copy.pop();
           
            pcur = acopy.front();
            acopy.pop();
           
            for(i = 0; i< cur->neighbors.size(); ++i){
                if(helper.find(cur->neighbors[i]->label) != helper.end())
                    pcur->neighbors.push_back(helper[cur->neighbors[i]->label]);
                else{
                    UndirectedGraphNode *tmp = new UndirectedGraphNode(cur->neighbors[i]->label);
                    copy.push(cur->neighbors[i]);
                    acopy.push(tmp);
                    helper[tmp->label] = tmp;
                    pcur->neighbors.push_back(tmp);
                }
            }
        }
        return head;
    }
};
```
###2. 被围绕的区域(LintCode 477. 被围绕的区域)
描述: 
给一个二维的矩阵，包含 'X' 和 'O', 找到所有被 'X' 围绕的区域，并用 'X' 填充满。 
Example: 
给出二维矩阵：

```
X X X X
X O O X
X X O X
X O X X 
```
把被 'X' 围绕的区域填充之后变为：

```
X X X X
X X X X
X X X X
X O X X
```
思路： 
Code:

```
class Solution {
public:
    /*
     * @param board: board a 2D board containing 'X' and 'O'
     * @return: nothing
     */
    void search(vector<vector<char>> &board, int i, int j){
        if(i < 0 || j < 0 || i >= board.size() || j >= board[0].size()) return;
        if(board[i][j] != 'O') return;
       
        board[i][j] = 'F';
        search(board, i-1, j);
        search(board, i+1, j);
        search(board, i, j-1);
        search(board, i, j+1);
    }
    void surroundedRegions(vector<vector<char>> &board) {
        // write your code here
        if(board.empty()) return;
        int i, j;
        for(i = 0; i < board.size(); ++i){
            if(board[i][0] == 'O') search(board, i, 0);
            if(board[i][board[0].size() - 1] == 'O') search(board, i, board[0].size() - 1);
        }
        for(j = 0; j < board[0].size(); ++j){
            if(board[0][j] == 'O') search(board, 0, j);
            if(board[board.size() - 1][j] == 'O') search(board, board.size() - 1, j);
        }
       
        for(i = 0; i< board.size(); ++i)
            for(j = 0; j< board[0].size(); ++j){
                if(board[i][j] == 'F') board[i][j] = 'O';
                else if(board[i][j] == 'O') board[i][j] = 'X';
            }
       
    }
};
```
###3. 拓扑排序(LintCode 127. 拓扑排序)
描述: 
给定一个有向图，图节点的拓扑排序被定义为： 

*  对于每条有向边A--> B，则A必须排在B之前 
*  拓扑排序的第一个节点可以是任何在图中没有其他节点指向它的节点　　 

找到给定图的任一拓扑排序 
Example: 
Code:  

```
/**
 * Definition for Directed graph.
 * struct DirectedGraphNode {
 *     int label;
 *     vector<DirectedGraphNode *> neighbors;
 *     DirectedGraphNode(int x) : label(x) {};
 * };
 */

class Solution {
public:
    /*
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*>& graph) {
        // write your code here
        vector<DirectedGraphNode*> res;
        if(graph.empty()) return res;
       
        stack<DirectedGraphNode*> node;
        map<DirectedGraphNode*, int> helper;

        int i, j;
        for(i = 0; i< graph.size(); ++i) helper[graph[i]] = 0;
       
        for(i = 0; i< graph.size(); ++i)
            for(j = 0; j< graph[i]->neighbors.size(); ++j)
                ++helper[graph[i]->neighbors[j]];
       
        for(i = 0; i < graph.size(); ++i)
            if(helper[graph[i]] == 0) node.push(graph[i]);
           
        while(!node.empty()){
            DirectedGraphNode* cur = node.top();
            node.pop();
            res.push_back(cur);
           
            for(i = 0; i< cur->neighbors.size(); ++i)
                if(--helper[cur->neighbors[i]] == 0) node.push(cur->neighbors[i]);
        }
       
        return res;
    }
};
```
###4. 单词接龙(LintCode 120. 单词接龙)
描述: 
给出两个单词（start和end）和一个字典，找到从start到end的最短转换序列  
比如：  
每次只能改变一个字母。  
变换过程中的中间单词必须在字典中出现。  
Example:   
给出数据如下： 
start = `"hit"`  
end = `"cog"`  
dict = `["hot","dot","dog","lot","log"]`  
一个最短的变换序列是 `"hit" -> "hot" -> "dot" -> "dog" -> "cog"`，  
返回它的长度 5  
Code:  

```
/*按照朴素的Dijkstra算法，数据量大时会超时*/
class Solution {
public:
    /*
     * @param start: a string
     * @param end: a string
     * @param dict: a set of string
     * @return: An integer
     */
    bool isAccessible(string &A, string &B){
        int count = 0;
        for(int i = 0; i< A.length();++i)
            if(A[i] == B[i]) ++count;
        if(count >= A.length() - 1) return true;
        else return false;
    }
    
    int ladderLength(string &start, string &end, unordered_set<string> &dict) {
        // write your code here
        map<string , int> help;
        vector<vector <int> > dis;
        vector<string> dict1;
        int min_dis, min_index;
        int i, j, count = 0;
        
        bool find_start = false, find_end = false;
        
        if(dict.find(start) != dict.end()) find_start = true;
        if(dict.find(end) != dict.end()) find_end = true;

        if(!find_start) dict1.push_back(start);
        for(auto t:dict) dict1.push_back(t);
        
        int size = dict1.size();
        
        for(i = 0; i < size; ++i){
            vector<int> tmp;
            for(j = 0; j < size; ++j){
                if(isAccessible(dict1[i], dict1[j])) tmp.push_back(1);
                else tmp.push_back(INT_MAX);
            }
            dis.push_back(tmp);
        }
        
        for(i = 0; i< dict1.size(); ++i) help[dict1[i]] = 0;
                
        help[start] = 1;
        
        int start_tag = -1, end_tag = -1;
        for(i = 0; i < dict1.size(); ++i){ 
            if(dict1[i] == start) start_tag = i;
            if(dict1[i] == end) end_tag = i;
            if(start_tag != -1 && end_tag != -1) break;
        }
        
        
        for(i = 0; i < size; ++i){
            min_dis = INT_MAX;
            for(j = 0; j< size; ++j){
                if(help[dict1[j]] == 0 && dis[start_tag][j] < min_dis){
                    min_dis = dis[start_tag][j];
                    min_index = j;
                }
            }
            
            help[dict1[min_index]] = 1;
            
            for(j = 0; j< size; ++j){
                if(help[dict1[j]] == 0 && dis[min_index][j] != INT_MAX && 
                min_dis + dis[min_index][j] < dis[start_tag][j])
                    dis[start_tag][j] = min_dis + dis[min_index][j];
            }
        }
        
        for(i = 0; i < size ; ++i) cout<<start<<" to "<<dict1[i]<<" : "<<dis[start_tag][i]<<endl;
        if(find_end){
            cout << dis[start_tag][end_tag]<<endl;
            return (dis[start_tag][end_tag] + 1);
        }
        else{
            min_dis = INT_MAX;
            for(i = 0; i < size; ++i)
                if(isAccessible(dict1[i], end) && dis[start_tag][i] < min_dis){
                    min_dis = dis[start_tag][i];
                }
            return min_dis != INT_MAX ? min_dis+2:0;
        }
        
    }
};
```
选择另一种方法，不用建立邻接表，直接BFS搜索即可:

```
class Solution {
public:
    /**
      * @param start, a string
      * @param end, a string
      * @param dict, a set of string
      * @return an integer
      */
    int ladderLength(string start, string end, unordered_set<string> &dict) {    
          
        vector<vector<string>> result;
        if(start.size() == 0 || end.size() == 0 || dict.size() == 0) {
            return 0;
        }
        
        //start 和 end 都为‘a’, dict 为‘b’ 答案是1？？？？？
        if(start == end) {
            return 1;
        }
        if(start.size() == end.size() && start.size() == 1) {
            return 2;
        }
        
        
        map<string, int> count; //到某个字符串时，序列的长度
        
        queue<string> qu;
        qu.push(start);
        dict.erase(start);
        count[start] = 1;
        
        int minLen = 0x7fffffff;
        vector<string> curList;
        
        while(!qu.empty() && dict.size() >= 0) {
            string curString = qu.front();
            qu.pop();
            int curLen = count[curString];
            for(int i = 0; i < curString.size(); ++i) {
                string tmp = curString;
                for(char j = 'a'; j <= 'z'; ++j) {
                    if(tmp[i] == j) {
                        continue;
                    } else {
                        tmp[i] = j;
                        
                        if(dict.find(tmp) != dict.end()) {
                            //cout << tmp << endl;
                            qu.push(tmp);
                            count[tmp] = curLen + 1;
                            dict.erase(tmp);
                            if(tmp == end) {
                                return count[tmp]; //end可能包含在dict中
                            }
                        } else if(tmp == end) {
                            //cout << tmp << endl;
                            count[tmp] = count[curString] + 1;
                            return count[tmp];
                        }
                    }
                }
            }
        } 
        
        return 0;
    } 
};
```
##链表
###1. LRU缓存策略(LintCode 134. LRU Cache)
描述: 
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: `get` and `set`.  
`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.  
`set(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.  
思路：注意图的宽度优先搜索，注意建立邻接表的方法。 
Code:  

```
#include<list>

class LRUCache {
public:
    /*
    * @param capacity: An integer
    */LRUCache(int capacity) : capacity(capacity) {} 
    /*
     * @param key: An integer
     * @return: An integer
     */
    int get(int key) {
        // write your code here
        if(recent.find(key) != recent.end()){
            put(key, pos[key].second);
            return pos[key].second;
        }
        return 0;
    }

    /*
     * @param key: An integer
     * @param value: An integer
     * @return: nothing
     */
    void set(int key, int value) {
        // write your code here
        if(recent.find(key) != recent.end())
            recent.erase(pos[key]);
        else if(recent.size() >= capacity){
            pos.erase(recent.back().front());
            recent.pop_back();
        }
        recent.push_front({key, value});
        pos[key] = recent.begin();
    }
private:
    int capacity;
    list<pair<int, int>> recent;
    unordered_map<int, list<int, int>::iterator> pos;
};
```
###2. 反转链表(LintCode 35. Reverse Linked List)  
描述: 
Reverse a linked list.  
Example:   
For linked list 1->2->3, the reversed linked list is 3->2->1   
Code:  

```
/**
 * Definition of singly-linked-list:
 *
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param head: n
     * @return: The new head of reversed linked list.
     */
    ListNode * reverse(ListNode * head) {
        // write your code here
        if(head == nullptr || head->next == nullptr) return head;
        
        ListNode *pcur = head;
        ListNode *cur = head->next;
        ListNode *tmp = head;

        while(cur != nullptr){
            pcur->next = cur->next;
            cur->next = tmp;
            tmp = cur;
            cur = pcur->next;
        }
        
        return tmp;
        
    }
};
```  
###3. 链表求和II(LintCode 35. Reverse Linked List)  
描述: 
You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in forward order, such that the 1's digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.  
Example:   
Given 6->1->7 + 2->9->5. That is, 617 + 295.
Return 9->1->2. That is, 912.  
思路：考虑两个链表长度不一样的情况，用堆栈。
Code:  

```
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param l1: The first list.
     * @param l2: The second list.
     * @return: the sum list of l1 and l2.
     */
    ListNode * addLists2(ListNode * l1, ListNode * l2) {
        // write your code here
        if(l1 == nullptr && l2 == nullptr) return l1;
        else if(l1 == nullptr) return l2;
        else if(l2 == nullptr) return l1;
        
        std::stack<int> R1, R2;
        
        while(l1 != NULL){
            R1.push(l1->val);
            l1 = l1->next;
        }
        
        while(l2 != NULL){
            R2.push(l2->val);
            l2 = l2->next;
        }
        
        int tmp = 0;

        int t1 = R1.top();
        int t2 = R2.top();
        R1.pop();
        R2.pop();
        
        ListNode *res = new ListNode((t1 + t2 + tmp)%10);
        tmp = (t1 + t2 + tmp) / 10;

        while(!R1.empty() && !R2.empty()){
            t1 = R1.top();
            t2 = R2.top();
            R1.pop();
            R2.pop();
            
            ListNode *tmpnode = new ListNode((t1 + t2 + tmp)%10);
            tmp = (t1 + t2 + tmp) / 10;

            tmpnode->next = res;
            res = tmpnode;
        }
        if(!R1.empty()){
            while(!R1.empty()){
                t1 = R1.top();
                R1.pop();
            
                ListNode *tmpnode = new ListNode((t1 + tmp) % 10);
                tmp = (t1 + tmp) / 10;
            
                tmpnode->next = res;
                res = tmpnode;
            }
        }else if(!R2.empty()){
            while(!R2.empty()){
                t1 = R2.top();
                R2.pop();
            
                ListNode *tmpnode = new ListNode((t1 + tmp) % 10);
                tmp = (t1 + tmp) / 10;
            
                tmpnode->next = res;
                res = tmpnode;
            }
        }
        if(tmp > 0){
            ListNode *tmpnode = new ListNode(tmp % 10);

            tmpnode->next = res;
            res = tmpnode;
        }
        return res;
    }
};
```
###4. 删除链表中的元素(LintCode 452. Remove Linked List Elements)  
描述: 
Remove all elements from a linked list of integers that have value val.  
Example:   
Given `1->2->3->3->4->5->3`, val = `3`, you should return the list as `1->2->4->5`  
Code:  

```
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param head: a ListNode
     * @param val: An integer
     * @return: a ListNode
     */
    ListNode * removeElements(ListNode * head, int val) {
        // write your code here
        if(head == NULL) return head;
        
        while(head && head->val == val) head = head->next;
            
        ListNode *p, *q;
        
        if(head != NULL && head->next != NULL){
            p = head; 
            q = head->next;
        }
        else return head;
        
        while(q != NULL){
            if(q->val == val){
                p->next = q->next;
                q = q->next;
            }
            else{
                p = p->next;
                q = q->next;
            }
        }
        
        return head;
    }
};
```
###5. 合并两个排序链表(LintCode 165. Merge Two Sorted Lists)  
描述: 
Merge two sorted (ascending) linked lists and return it as a new sorted list. The new sorted list should be made by splicing together the nodes of the two lists and sorted in ascending order.  
Example:   
Given `1->3->8->11->15->null`, `2->null` , return `1->2->3->8->11->15->null`.  
Code:  

```
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param l1: ListNode l1 is the head of the linked list
     * @param l2: ListNode l2 is the head of the linked list
     * @return: ListNode head of linked list
     */
    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {
        // write your code here
        if(l1 == NULL) return l2;
        else if(l2 == NULL) return l1;
        
        ListNode* phead = new ListNode(-1);
        ListNode* pcur = phead;
        while(l1 != NULL && l2 != NULL){
            if(l1->val < l2->val){
                pcur->next = l1;
                l1 = l1->next;
                pcur = pcur->next;
            }
            else{
                pcur->next = l2;
                l2 = l2->next;
                pcur = pcur->next;
            }
        }
        if(l1 != NULL) pcur->next = l1;
        if(l2 != NULL) pcur->next = l2;
        
        return phead->next;
    }
};
```
###6. 两个链表的交叉(LintCode 380. Intersection of Two Linked Lists)  
描述: 
Write a program to find the node at which the intersection of two singly linked lists begins.    
Example:   
The following two linked lists:  

```
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3  
```
begin to intersect at node c1.  
Code:  

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    /*
     * @param headA: the first list
     * @param headB: the second list
     * @return: a ListNode
     */
    int findlength(ListNode *head){
        int count = 1;
        if(head == NULL) return 0;
        while(head != NULL){
            head = head->next;
            ++count;
        }
        return count;
    }
    
    ListNode* walkstep(int count, ListNode *head){
        while(count--) head = head->next;
        return head;
    }
    
    ListNode * getIntersectionNode(ListNode * headA, ListNode * headB) {
        // write your code here
        int length_a = findlength(headA);
        int length_b = findlength(headB);
        if(length_a == 0 || length_b == 0) return NULL;
        ListNode *pheadA = headA, *pheadB = headB;
        
        if(length_a > length_b) pheadA = walkstep(length_a - length_b, pheadA);
        else pheadB = walkstep(length_b - length_a, pheadB);
        
        cout<<"hhhh"<<endl;
        while(pheadA != NULL){
            if(pheadA == pheadB) return pheadA;
            pheadA = pheadA->next;
            pheadB = pheadB->next;
        }
        
        return NULL;
    }
};
```
###7. 翻转链表 II(LintCode 36. 翻转链表 II)  
描述: 
翻转链表中第m个节点到第n个节点的部分     
Example:   
给出链表`1->2->3->4->5->null`， `m = 2` 和`n = 4`，返回`1->4->3->2->5->null`   
思路：注意每一步移动链表的方法，选择最简洁的步骤。  
Code:  

```
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param head: ListNode head is the head of the linked list 
     * @param m: An integer
     * @param n: An integer
     * @return: The head of the reversed ListNode
     */
    ListNode * reverseBetween(ListNode * head, int m, int n) {
        // write your code here
        if(!head || head->next == nullptr || n == m) return head;
        int i;
        ListNode *ptr = new ListNode(0);
        ptr->next = head;
        ListNode *pre = ptr;
        
        for(i = 1; i < m; ++i) pre = pre->next;
        ListNode *cur = pre->next;
        
        for(i = m; i < n ; ++i){
            ListNode *move = cur->next;
            cur->next = move->next;
            move->next = pre->next;
            pre->next = move;
        }
        
        return ptr->next;
    }
};
```
###8. 带环链表(LintCode 102. Linked List Cycle)  
描述: 
Given a linked list, determine if it has a cycle in it.     
Example:   
Given `-21->10->4->5`, tail connects to node index `1`, return `true`    
思路：注意每一步移动链表的方法，选择最简洁的步骤。  
Code:  

```
/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this->val = val;
 *         this->next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /*
     * @param head: The first node of linked list.
     * @return: True if it has a cycle, or false
     */
    bool hasCycle(ListNode * head) {
        // write your code here
        if(head == nullptr || head->next == nullptr) return false;
        ListNode *fast = head, *slow = head;
        
        while(fast->next != nullptr && fast->next->next != nullptr){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) return true;
        }
        return false;
    }
};
```
##枚举法
###1. 统计数字(LintCode 3. Digit Counts)
描述: 
Count the number of k's between 0 and n. k can be 0 - 9.  
Example:  
if n = 12, k = 1 in  
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
```

we have FIVE 1's (1, 10, 11, 12)
思路: 想清楚每一位怎么数数字的个数。
Code:  

```
class Solution {
public:
    /*
     * @param : An integer
     * @param : An integer
     * @return: An integer denote the count of digit k in 1..n
     */
    int digitCounts(int k, int n) {
        // write your code herezo
        if(n < k) return 0;
        int count = 0, flag = 1, base = 1;
        if(k == 0 && n < 10) return 1;
        if(k == 0) flag = 10;
        
        while(n / base >= flag){
            int cur_num = n%(base*10)/base;
            int high = n/(base*10);
            int low = n % base;
            if(cur_num < k) count += high*base;
            else if(cur_num == k) count += high*base + low + 1;
            else count += (high + 1) * base;
            
            base *= 10;
        }
        
        return count;
    }
};
```
###2. 名人确认(LintCode 645. Find the Celebrity)
描述: 
Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.  
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).  
You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.  
Example:  
Given n = 2  

```
2 // next n * (n - 1) lines   
0 knows 1  
1 does not know 0    
```
return 1 // 1 is celebrity  
思路: 注意判断条件的利用（每一次比较只有两种情况，knows(a, b)是true的话，那么a肯定不是candidate; knows(a, b)是false的话，那么b肯定不是candidate. 所以一直比较到最后会留下一个candidate，然后我们再验证这个是不是正解。）  
Code:  

```
// Forward declaration of the knows API.
bool knows(int a, int b);

class Solution {
public:
    /**
     * @param n a party with n people
     * @return the celebrity's label or -1
     */
    int findCelebrity(int n) {
        // Write your code here
        int celebrity = 0;
        for(int i = 1; i < n; ++i){
            if(knows(celebrity, i)) celebrity = i;
        }
        for(int i = 0; i < n; ++i){
            if(i != celebrity &&(knows(celebrity, i) || !knows(i, celebrity))) return -1;
        }
        return celebrity;
    }
};
```
###3. 最大子数组差(LintCode 45. 最大子数组差)
描述: 
给定一个整数数组，找出两个不重叠的子数组A和B，使两个子数组和的差的绝对值|SUM(A) - SUM(B)|最大。  
返回这个最大的差值。  
Example:  
给出数组`[1, 2, -3, 1]`，返回 6  
思路：分别求出左右两边的最大和最小子数组，然后求差。
Code:  

```
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @return: An integer indicate the value of maximum difference between two substrings
     */
    int maxDiffSubArrays(vector<int> &nums) {
        // write your code here
        if(nums.empty()) return 0;
        int pos, neg, max, min, i;
        int size = nums.size();
        
        int *maxleft = new int[size];
        int *maxright = new int[size];
        int *minleft = new int[size];
        int *minright = new int[size];
        
        pos = nums[0];
        max = pos;
        maxleft[0] = pos;
        for(i = 1; i < size; i++){
            if(pos >= 0) pos += nums[i];
            else pos = nums[i];
            if(pos > max) max = pos;
            maxleft[i] = max;            
        }
        
        pos = nums[size - 1];
        max = pos;
        maxright[size - 1] = pos;
        for(i = size - 2; i >=0; i--){
            if(pos >= 0) pos += nums[i];
            else pos = nums[i];
            if(pos > max) max = pos;

            maxright[i] = max;
        }
        
        neg = nums[0];
        min = neg;
        minleft[0] = min;
        for(i = 1; i < size; i++){
            if(neg <= 0) neg += nums[i];
            else neg = nums[i];
            if(neg < min) min = neg;
            
            minleft[i] = min;
        }
        
        neg = nums[size - 1];
        min = neg;
        minright[size - 1] = min;
        for(i = size - 2; i >= 0; i--){
            if(neg <= 0) neg += nums[i];
            else neg = nums[i];
            if(neg < min) min = neg;
            
            minright[i] = min;
        }
        
        int result1 = 0;
        int result2 = 0;
        for(i = 0; i < size - 1; i++){
            result1 = result1 > maxleft[i] - minright[i+1] ? result1:(maxleft[i] - minright[i+1]);
            result2 = result2 > maxright[i+1] - minleft[i] ? result2:(maxright[i+1] - minleft[i]);
        }
        
        return result1 > result2 ? result1: result2;
        
    }
};
```
###4. 最长公共前缀(LintCode 78. 最长公共前缀)
描述: 
给k个字符串，求出他们的最长公共前缀(LCP)  
Example:  
在 `"ABCD" "ABEF"` 和 "ACEF" 中,  LCP 为 `"A"`  
在 `"ABCDEFG", "ABCEFG", "ABCEFA"` 中, LCP 为 `"ABC"`  
Code:  

```
class Solution {
public:
    /**
     * @param strs: A list of strings
     * @return: The longest common prefix
     */
    string longestCommonPrefix(vector<string> &strs) {
        // write your code here
        string res = "";
        if(strs.empty()) return res;
        int size = strs.size();
        string flag = strs[0];
        
        for(int i = 0; i < flag.length(); ++i){
            char tmp = flag[i];
            for(int k = 0; k < size; ++k){
                string tmp2 = strs[k];
                if(i <= tmp2.length() && tmp2[i] == tmp) continue;
                else return res;
            }
            res += tmp;
        }
        
        return res;
    }
};
```
##排序
###1. 快排(LintCode 464. Sort Integers II)
描述: 
Given an integer array, sort it in ascending order. Use quick sort, merge sort, heap sort or any O(nlogn) algorithm.  
Example:  
Given `[3, 2, 1, 4, 5]`, return `[1, 2, 3, 4, 5]`.  
Code:  

```
class Solution {
public:
    void swap(int *a, int *b){
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
    
    int partition(vector<int> &A, int start, int end){
        int i = start;
        int j = end + 1;
        while(true){
            while(A[++i] < A[start]) if(i == end) break;
            while(A[--j] > A[start]) if(j == start) break;
            if(i >= j ) break;
            swap(&(A[i]), &(A[j]));        
        }
        return j;
    }
    
    void quicksort(vector<int> &A, int start, int end){
        if(start >= end) return;
        int j = partition(A, start, end);
        quicksort(A, start, j-1);
        quicksort(A, j+1, end);
    }
    
    void sortIntegers2(vector<int> &A) {
        // write your code here
        quicksort(A, 0, A.size());
    }
};
```
###2. 摆动排序(LintCode 464. Sort Integers II)
描述: 
Given an unsorted array nums, reorder it in-place such that  
`nums[0] <= nums[1] >= nums[2] <= nums[3]....`  
Example:  
Given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].  
Code:  

```
class Solution {
public:
    /*
     * @param nums: A list of integers
     * @return: nothing
     */
    void swap(int *a, int *b){
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
    
    void wiggleSort(vector<int> &nums) {
       
       for (int i = 1; i < nums.size(); ++i) {
           if(i % 2 == 0 && nums[i] > nums[i-1]) swap( &(nums[i]), &(nums[i - 1]) );
           if(i % 2 == 1 && nums[i] < nums[i-1]) swap( &(nums[i]), &(nums[i - 1]) );
       }
        
    }
};
```
###3. 最大间距(LintCode 400. Maximum Gap)
描述: 
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.  
Return 0 if the array contains less than 2 elements.  
Example:  
Given `[1, 9, 2, 5]`, the sorted form of it is `[1, 2, 5, 9]`, the maximum gap is between `5` and `9` = `4`.  
思路：利用桶排序。
Code:  

```
class Solution {
public:
    /**
     * @param nums: an array of integers
     * @return: the maximun difference
     */
    int get_max(vector<int> &nums){
        
        int maxval = nums[0];
        for(int i = 1; i < nums.size(); ++i) maxval = maxval > nums[i] ? maxval : nums[i];
        return maxval;
    }
    
    int get_min(vector<int> &nums){
        int minval = nums[0];
        for(int i = 1; i < nums.size(); ++i) minval = minval < nums[i] ? minval : nums[i];
        return minval;
    }
    
    int compare(int i, int j){
        return i > j ? i : j;
    }
    
    int maximumGap(vector<int> &nums) {
        // write your code here
        if(nums.size() < 2) return 0;
        int size = nums.size();
    
        int maxval = get_max(nums);
        int minval = get_min(nums);
        
        if(maxval == minval) return 0;
        
        int inter = (maxval - minval) / size + 1;
        vector<vector<int> > bucket((maxval - minval) / inter + 1);
        
        for(int i = 0; i < size; ++i){
            int bnum = (nums[i] - minval) / inter;
            if(bucket[bnum].empty()){
                bucket[bnum].push_back(nums[i]);
                bucket[bnum].push_back(nums[i]);
            }
            else{
                if(nums[i] > bucket[bnum][1]) bucket[bnum][1] = nums[i];
                else if(nums[i] < bucket[bnum][0]) bucket[bnum][0] = nums[i];
            }
        }

        int gap = 0, last = 0;
        
        if(!bucket[0].empty()) gap = bucket[0][1] - bucket[0][0];
        for(int i = 1; i < bucket.size(); ++i){
            if(bucket[i].empty()) continue;
            else{
                int tmp = compare(bucket[i][1] - bucket[i][0], bucket[i][0] - bucket[last][1]);
                gap = max(gap, tmp);
                last = i;
            }
        }
        
        return gap;
    }
};
```
###4. 最接近零的子数组和(LintCode 139. 最接近零的子数组和)
描述: 
给定一个整数数组，找到一个和最接近于零的子数组。返回第一个和最右一个指数。你的代码应该返回满足要求的子数组的起始位置和结束位置  
Example:  
给出`[-3, 1, 1, -3, 5]`，返回`[0, 2]`，`[1, 3]`， `[1, 1]`， `[2, 2]` 或者 `[0, 4]`。  
Code:  

```

class Solution {
public:
    /*
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number and the index of the last number
     */
    
    vector<int> subarraySumClosest(vector<int> &nums) {
        // write your code here
        vector<int> res;
        if(nums.empty()) return res;
        int size = nums.size();
        if(size == 1) {
            res.push_back(0);
            res.push_back(0);
            return res;
        }
        vector<pair<int, int> > sum;
        sum.push_back(make_pair(0, -1));
        int tmp = nums[0];
        sum.push_back(make_pair(tmp, 0));
        
        for(int i = 1; i < size; ++i){
            tmp += nums[i];
            sum.push_back(make_pair(tmp, i));
        }
        sort(sum.begin(), sum.end());
        int start, end, diff = INT_MAX;
        for(int i = 1; i < sum.size(); ++i){
            if(abs(sum[i].first - sum[i - 1].first) < diff){
                diff = abs(sum[i].first - sum[i - 1].first);
                start = min(sum[i].second, sum[i - 1].second) + 1;
                end = max(sum[i].second, sum[i - 1].second);
            }
        }
        res.push_back(start);
        res.push_back(end);
        return res;
    }
};
```  
###5. 最大数(LintCode 184. 最大数)
描述: 
给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。  
Example:  
给出 `[1, 20, 23, 4, 8]`，返回组合最大的整数应为`8423201`。  
Code:  

```
class Solution {
public:
    /**
     * @param nums: A list of non negative integers
     * @return: A string
     */
    
    static bool compare(string strnum1, string strnum2){
        string res1 = strnum1 + strnum2;
        string res2 = strnum2 + strnum1;
        return res1 > res2;
    }
    
    string largestNumber(vector<int> &nums) {
        // write your code here
        
        string res = "";
        if(nums.empty()) return res;
        
        vector<string> numstr;
        
        for(auto c : nums) numstr.push_back(to_string(c));
        
        sort(numstr.begin(), numstr.end(), compare);
        
        for(auto c : numstr) res += c;
        if(res[0] == '0') return "0";
        return res;
    }
};
```
###6. 四数之和(LintCode 58. 四数之和)
描述: 
给一个包含n个数的整数数组S，在S中找到所有使得和为给定整数target的四元组(a, b, c, d)。  
Example:  
例如，对于给定的整数数组S=[1, 0, -1, 0, -2, 2] 和 target=0. 满足要求的四元组集合为：  
`(-1, 0, 0, 1)`  
`(-2, -1, 1, 2)`  
`(-2, 0, 0, 2)`  
Code:  

```
class Solution {
public:
    /**
     * @param numbers: Give an array
     * @param target: An integer
     * @return: Find all unique quadruplets in the array which gives the sum of zero
     */
    vector<vector<int>> fourSum(vector<int> &numbers, int target) {
        // write your code here
        vector<vector<int> > res;
        if(numbers.empty()) return res;
        int size = numbers.size();
        sort(numbers.begin(), numbers.end());
        
        for(int i = 0; i < size - 3; ++i){
            if( i != 0 && numbers[i] == numbers[i - 1]) continue;
            
            for(int j = i + 1; j < size - 2; ++j){
                
                if( j != i + 1 && numbers[j] == numbers[j - 1]) continue;
                
                int left = j + 1, right = size - 1;
                while(left < right){
                    int sum = numbers[i] + numbers[j] + numbers[left] + numbers[right]; 
                    if(sum > target) right--;
                    else if(sum < target) left++;
                    else{
                        vector<int> tmp;
                        tmp.push_back(numbers[i]);
                        tmp.push_back(numbers[j]);
                        tmp.push_back(numbers[left]);
                        tmp.push_back(numbers[right]);
                        res.push_back(tmp);
                        left++;
                        right--;
            
                        while(left < right && numbers[left] == numbers[left - 1]) left++;
                        while(left < right && numbers[right] == numbers[right + 1]) right--;
                    }
                }
                
            }
        }
        return res;
    }
};
```
###7. 数组划分(LintCode 31. 数组划分)
描述: 
给出一个整数数组 nums 和一个整数 k。划分数组（即移动数组 nums 中的元素），使得：  
所有小于k的元素移到左边  
所有大于等于k的元素移到右边  
返回数组划分的位置，即数组中第一个位置 i，满足 nums[i] 大于等于 k。  
Example:  
给出数组 nums = `[3,2,2,1]` 和 `k = 2`，返回 `1`.  
Code:  

```
class Solution {
public:
    /**
     * @param nums: The integer array you should partition
     * @param k: An integer
     * @return: The index after partition
     */
    void swap(vector<int> &nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    
    int partitionArray(vector<int> &nums, int k) {
        // write your code here
        if(nums.empty()) return 0;
        nums.insert(nums.begin(), k);
        int size = nums.size();
        int i = 0, j = size;
        while(true){
            while(nums[++i] < nums[0]) if(i == size - 1) break;
            while(nums[--j] >= nums[0]) if(j == 0) break;
            if(i >= j) break;
            swap(nums, i, j);
        }
        swap(nums, 0, j);
        for(auto c:nums) cout<<c<<endl;
        
        while(j > 0 && nums[j] == nums[j-1]) --j;
        return j;
    }
};
```
###7. 第k大元素(LintCode 5. 第k大元素)
描述: 
在数组中找到第k大的元素  
Example:  
给出数组 [9,3,2,4,8]，第三大的元素是 4  
给出数组 [1,2,3,4,5]，第一大的元素是 5，第二大的元素是 4，第三大的元素是 3，以此类推   
Code:  

```
class Solution {
public:
    /*
     * @param n: An integer
     * @param nums: An array
     * @return: the Kth largest element
     */
    void swap(vector<int> &nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    
    int partition(vector<int> &nums, int low, int high){
        int i = low, j = high + 1;
        while(true){
            while(nums[++i] > nums[low]) if(i == high) break;
            while(nums[--j] < nums[low]) if(j == low) break;
            if(i >= j) break;
            swap(nums, i ,j);
        }
        swap(nums, low, j);
        return j;
    }
    int quicksort(vector<int> &nums, int low, int high, int k){
        //if(low >= high) return;
        int j = partition(nums, low, high);
        if(j == k - 1) return nums[j];
        else if(j > k - 1) return quicksort(nums, low, j - 1, k);
        else if(j < k - 1) return quicksort(nums, j + 1, high, k);
    }
    
    int kthLargestElement(int n, vector<int> &nums) {
        // write your code here
        if(nums.empty()) return 0;

        return quicksort(nums, 0, nums.size() - 1, n);
    }
};
```
###8. 排颜色(LintCode 143. 排颜色 II)
描述: 
给定一个有n个对象（包括k种不同的颜色，并按照1到k进行编号）的数组，将对象进行分类使相同颜色的对象相邻，并按照1,2，...k的顺序进行排序。  
Example:  
给出colors = `[3, 2, 2, 1, 4]`，k=`4`, 你的代码应该在原地操作使得数组变成`[1, 2, 2, 3, 4]`  
Code:  

```
class Solution {
public:
    /**
     * @param colors: A list of integer
     * @param k: An integer
     * @return: nothing
     */
    

    void sortColors2(vector<int> &colors, int k) {
        // write your code here
        
        int index = 0;
        while(index < colors.size()){
            int cnt = colors[index] - 1;
            if(colors[index] <= 0) ++index;
            else{
                if(colors[cnt] <= 0){
                    --colors[cnt];
                    colors[index] = 0;
                    ++index;
                }else{
                    swap(colors[index], colors[cnt]);
                    colors[cnt] = -1;
                }
            }
        }
        
        int i = colors.size() - 1;
        while(i >= 0){
            for(int j = 0; j > colors[k - 1]; --j) colors[i--] = k;
            k--;
        }
    }
};
```
