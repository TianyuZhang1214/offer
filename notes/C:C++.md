<!-- GFM-TOC -->
* [概览](#概览)
* [变量类型](#变量类型)
* [数组](#数组)
* [字符串操作](#字符串操作)
* [内存管理](#内存管理)
* [函数指针](#函数指针)
* [对象和类](#对象和类)
* [类和动态内存分配](#类和动态内存分配)
* [网络操作](#网络操作)
    * [1. InetAddress](#1-inetaddress)
    * [2. URL](#2-url)
    * [3. Sockets](#3-sockets)
    * [4. Datagram](#4-datagram)
* [NIO](#nio)
    * [1. 流与块](#1-流与块)
    * [2. 通道与缓冲区](#2-通道与缓冲区)
        * [2.1 通道](#21-通道)
        * [2.2 缓冲区](#22-缓冲区)
    * [3. 缓冲区状态变量](#3-缓冲区状态变量)
    * [4. 读写文件实例](#4-读写文件实例)
    * [5. 阻塞与非阻塞](#5-阻塞与非阻塞)
        * [5.1 阻塞式 I/O](#51-阻塞式-io)
        * [5.2 非阻塞式 I/O](#52-非阻塞式-io)
    * [6. 套接字实例](#6-套接字实例)
        * [6.1 ServerSocketChannel](#61-serversocketchannel)
        * [6.2 Selectors](#62-selectors)
        * [6.3 主循环](#63-主循环)
        * [6.4 监听新连接](#64-监听新连接)
        * [6.5 接受新的连接](#65-接受新的连接)
        * [6.6 删除处理过的 SelectionKey](#66-删除处理过的-selectionkey)
        * [6.7 传入的 I/O](#67-传入的-io)
* [参考资料](#参考资料)
<!-- GFM-TOC -->

#变量类型
c语言中变量分为四类，分别是
1.auto   自动变量(局部变量)
2.static   静态存贮分配变量（又分为内部静态和外部静态）
3.extern  全程变量（用于外部变量说明）
4.register  寄存器变量（分配在硬件寄存器中）
作用域图：
                    

#数组
##下标引用
```
//一维数组
array[subscript]  <---->  *( array + ( subscript ) ) ;
//多维数组
array[row][col]  <---->  *( (array + row) + ( col ) ) ;
```
##初始化

#字符串
字符串必须以NUL结尾！
库函数：   

```
//长度不受限的函数
size_t strlen( char const * string );  //返回值为无符号数，如需比较大小，最好先转换为int
char *strcpy( char *dst, char const *src ); //使用时需保证目标字符数组的空间足以容纳需要复制的字符串，否则会覆盖其他内存空间
char *strcat( char *dst, char const *src ); //使用时需保证目标字符数组剩余的空间足以保存整个源字符串
int strcmp( char const *s1, char const *s2 ); //s1>s2: return 1; s1=s2:return 0; s1<s2:return -1 
//长度受限的函数，可能会造成结果不再是字符串
char *strcpy( char *dst, char const *src , size_t len); //使用时需保证目标字符数组的空间足以容纳需要复制的字符串，否则会覆盖其他内存空
char *strcat( char *dst, char const *src , size_t len); //使用时需保证目标字符数组剩余的空间足以保存整个源字符串
int strcmp( char const *s1, char const *s2 , size_t len); //s1>s2: return 1; s1=s2:return 0; s1<s2:return -1 
//字符串查找
char *strchr( char const *str, int ch ); //返回字符第一个出现位置的指针
char *strchr( char const *str, int ch ); //返回字符最后一个出现位置的指针
char *strpbrk( char const *str, char const *group ); /
/返回一组字符中第一个出现位置的指针
char *strstr( char const *s1, char const *s2 ); //返回字符串第一个出现位置的指针
size_t strspn(const char *str, const char * accept); //返回字符串 str 开头连续包含字符串 accept 内的字符数目。
```
#内存管理  
1. 从静态存储区域分配：内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static变量等。
2. 在栈上分配：在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 从堆上分配：即动态内存分配。程序在运行的时候用malloc 或new申请任意大小的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。一个 C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。

- Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）
- Data：这里存放的是初始化过的全局变量
- BSS：这里存放的是未初始化的全局变量
- Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存
- Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长
- Stack：这是栈区域，自高地址向低地址增长。  

#函数指针  
##1. 作为参数传递给另一个函数(回调函数)  

```
#include <stdio.h>

//返回值(*指针名)(参数列表)
typedef int (*callback)(int,int);
//回调函数
int ADD(callback p, int a, int b){
    return (*p)(a,b);//此处回调add函数...
}
//普通函数
int add(int a, int b){
    return a + b;
}

int main(void){
    printf("%d\n",add(1,2));
    printf("%d\n",ADD(add,1,2));
    return 0;
}
```  
可参考C中algorithm库中sort的实现。  
##2. 转移表  
实现计算器功能的程序如下： 
 
```
switch(operation)
{
      case ADD:
              result=add(a,b);break;
      case SUB:
              result=sub(a,b);break;
      case MUL:
              result=mul(a,b);break;
      case DIV:
              result=div(a,b);break;
      .....
}
```  
如前面所言，如果这个计算器要实现的功能很多，那么将有很多这样的语句，可维护性很差。如果我们将具体的数值操作与选择操作的代码分开将会提高代码的可读性。这种情况下，我们需要建立一个“转移表”。在建立转移表之间需要对涉及到的函数提前声明，然后建立转移表，对于上面的可以这么修改：

```
double add(double,double);
double sub(double,double);
double mul(double,double);
double div(double,double);
......
```
那么建立的转移表如下： 

```
double (*operation_fun[])(double,double)={add,sub,mul,div,......};
```
在调用的时候可以这样操作： 

```
double result;
result=operation_fun[operation](a,b);
```

#对象和类
1. 封装：私有数据成员存储信息，公有成员函数提供访问数据的唯一途径，数据私有性实现数据隐藏和封装。  
2. 类是用户定义的类型，对象是类的实例。用户定义的类型与标准类型相似。
3. 每个对象都存储自己的数据，而共享类方法。对象通过使用成员操作符“.”调用成员函数，如：`mr_object.try_me()`。在OOP中，这种函数调用被称为将try_me消息发送给mr_object对象，在try_me()方法中引用类数据成员时，将使用mr_object对象相应的数据成员。
4. 如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。this指针被设置成调用对象的地址。
5. 类的使用

#类和动态内存分配
1. 静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域操作符来指出静态成员所属的类，但如果静态成员是整型或枚举型const，则可以在类声明中初始化。  
[静态数据成员与静态成员函数](https://www.cnblogs.com/qionglouyuyu/p/4620401.html)
2. 构造函数，拷贝构造函数和赋值函数(详见: 	[C++中构造函数，拷贝构造函数和赋值函数的区别和实现](https://blog.csdn.net/zcyzsy/article/details/52132936))：
	* 构造函数是一种特殊的类成员函数，是当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存。（构造函数的命名必须和类名完全相同）。
	* 拷贝构造函数是C++独有的，它是一种特殊的构造函数，用基于同一类的一个对象构造和初始化另一个对象。
	* 当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。  
3. 常规new和布局new(详见: [两种new](https://blog.csdn.net/qq_28306361/article/details/52747936))
	* 常规new负责在堆(heap)中找到一个能够满足要求的内存块
	* 布局new能够在分配内存时指定内存位置
	* 对于对象的操作: (1)程序员想用布局new创建多个对象时，必须提供两个不同的缓冲区地址，否则新对象会覆盖第一个对象的内存空间; 
	(2)使用布局new为对象分配内存时，必须确保析构函数被调用，但同时，我们又不能使用 delete pc1；这样的方式来做，因此必须显式地	为使用布局new操作符创建的对象调用析构函数，我们删除的时候，应当以创建顺序相反的顺序进行删除，因此晚创建的对象可能依赖于早创	建的对象。仅当所有对象都被销毁后，才能释放存储这些对象的缓冲区。

#类继承
1. 基类和派生类:  
	（1）派生类的特性:  
	* 派生类对象存储了基类的数据成员(派生类继承了基类的实现);
	* 派生类对象可以使用基类的方法（派生类继承了基类的接口），在基类方法不私有的情况下;
	* 派生类需要自己构造函数;
	* 派生类可以根据需要添加额外的数据成员和成员函数。
	* 派生类不能直接访问基类的私有成员，必须通过基类的方法进行访问。
	* 调用关系：创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数，基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数，可以使用初始化器列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。
2. 
	
